{"meta":{"title":"Lemon_Fruit","subtitle":"","description":"","author":"null","url":"https://lemon-fruit.github.io","root":"/"},"pages":[{"title":"","date":"2021-03-03T08:04:49.667Z","updated":"2021-03-03T08:04:49.667Z","comments":true,"path":"friends/index.html","permalink":"https://lemon-fruit.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T08:00:59.874Z","updated":"2021-03-03T08:00:59.874Z","comments":true,"path":"about/index.html","permalink":"https://lemon-fruit.github.io/about/index.html","excerpt":"","text":"这个人很懒，什么都没留下.jpg"},{"title":"","date":"2021-03-03T08:12:39.086Z","updated":"2021-03-03T08:12:39.086Z","comments":true,"path":"404.html","permalink":"https://lemon-fruit.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-03-03T08:01:55.133Z","updated":"2021-03-03T08:01:55.133Z","comments":true,"path":"categories/index.html","permalink":"https://lemon-fruit.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T08:03:26.389Z","updated":"2021-03-03T08:03:26.389Z","comments":true,"path":"mylist/index.html","permalink":"https://lemon-fruit.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-03T08:02:33.808Z","updated":"2021-03-03T08:02:33.808Z","comments":true,"path":"tags/index.html","permalink":"https://lemon-fruit.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Spring5","date":"2021-04-08T11:45:18.229Z","updated":"2021-03-09T09:47:32.514Z","comments":true,"path":"2021/04/08/Spring5/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/08/Spring5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CPU上下文切换","slug":"CPU上下文切换","date":"2021-04-08T08:50:33.000Z","updated":"2021-04-08T09:56:32.164Z","comments":true,"path":"2021/04/08/CPU上下文切换/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/08/CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","excerpt":"CPU上下文切换 什么是CPU上下文 ​ CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境.","text":"CPU上下文切换 什么是CPU上下文 ​ CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境. CPU上下文切换的类型： 进程上下文切换 线程上下文切换 中断上下文切换 系统调用 从用户态到内核态转变，需要用到系统调用 一次系统调用的过程，其实发生了两次CPU上下文问切换 系统调用过程中一直是同一个进程在运行 进程上下文切换 进程是由内核来管理和调度的，进程的切换只能发生在内核态 线程上下文切换 线程是调度的基本单位，而进程则是资源拥有的基本单位 线程有自己的私有数据，比如栈和寄存器 中断上下文切换 对同一个CPU，中断处理比进程拥有跟高的优先级 中断上下文切换并不涉及到进程的用户态","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Lemon"},{"title":"JVM","slug":"JVM","date":"2021-03-31T07:19:58.000Z","updated":"2021-04-08T11:55:38.518Z","comments":true,"path":"2021/03/31/JVM/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/31/JVM/","excerpt":"","text":"JMM 什么是JMM JMM：java 内存模型 作用：缓存一致性协议，用于定义数据读写的规则","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-03T03:39:33.817Z","updated":"2021-03-03T03:39:33.817Z","comments":true,"path":"2021/03/03/hello-world/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"JUC","slug":"JUC","date":"2021-03-01T11:34:49.000Z","updated":"2021-04-08T11:56:26.275Z","comments":true,"path":"2021/03/01/JUC/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/01/JUC/","excerpt":"JUC3.Lock锁（重点） Synchronized 和 Lock区别","text":"JUC3.Lock锁（重点） Synchronized 和 Lock区别 Synchronized 内置的java关键词，Lock是一个java类 Synchronized 无法 判断获取所得状态，Lock 可以判断是否获取到了锁 Synchronized 会自动释放，Lock必须手动释放锁！如果不是释放锁，死锁 Synchronized 线程1（获得锁），线程2（等待）；Lock锁就不一定等待下去 Synchronized 可重入锁，不可以中断的，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置） Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码 4、生产者和消费者4.1 生产者与消费者问题Synchronized 版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.swpu.pc;/** * 线程之间的通信问题:生产者消费者问题，等待唤醒，通知唤醒 * 线程交替进行 A B 操作同一个变量 num=0 * A num + 1 * B num - 1 */public class A &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data &#123; private int number = 0; public synchronized void increment() throws InterruptedException &#123; if (number != 0) &#123; this.wait(); &#125; number++; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125; public synchronized void decrement() throws InterruptedException &#123; if (number == 0) &#123; this.wait(); &#125; number--; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125;&#125; 问题存在，A B C D 四个线程 （虚假唤醒） if 改为 while 判断 4.2 JUC 版的生产者和消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class B &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data2 &#123; private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void increment() throws InterruptedException &#123; lock.lock(); try &#123; while (number != 0) &#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public synchronized void decrement() throws InterruptedException &#123; lock.lock(); try &#123; while (number == 0) &#123; condition.await(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; Condition 精准的通知和唤醒线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class C &#123; public static void main(String[] args) &#123; Data3 data = new Data3(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printA(); &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printB(); &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printC(); &#125; &#125;, &quot;C&quot;).start(); &#125;&#125;class Data3 &#123; private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; //1 A 2 B 3 C public void printA() &#123; lock.lock(); try &#123; //业务，判断-&gt; 执行 -&gt; 通知 while (number != 1) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;AAAAAAAAA&quot;); number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; lock.lock(); try &#123; while (number != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;BBBBBBBB&quot;); number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; lock.lock(); try &#123; while (number != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;CCCCCCCCCC&quot;); number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 5、八锁现象彻底理解锁 小结 new this 具体的一个手机 static Class 唯一的一个模板 6、集合类不安全6.1 List 不安全1234567891011121314151617181920212223242526272829303132333435package com.swpu.unsafe;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;public class ListTest &#123; public static void main(String[] args) &#123; //并发下ArrayList不安全的 /* 解决方案： 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ //List&lt;String&gt; list = new ArrayList&lt;&gt;(); //List&lt;String&gt; list = new Vector&lt;&gt;(); List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); /* CopyOnWrite 写入时复制 计算机程序设计领域的一种优化策略 多个线程调用的的时候，list，读取的时候，固定的，写入（覆盖） 在写入的时候避免覆盖，造成数据问题 读写分离 */ //List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 6.3 Map 不安全12345678910111213141516171819202122package com.swpu.unsafe;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;public class MapTest &#123; public static void main(String[] args) &#123; //Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 80; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 7. Callable 可以有返回值 可以抛出异常 方法不同，run()/call() 123456789101112131415161718192021222324252627package com.swpu.callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask, &quot;A&quot;).start(); Integer o = (Integer) futureTask.get(); System.out.println(o); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;Call()&quot;); return 1024; &#125;&#125; 细节： 有缓存 结果可能需要等待，会阻塞！ 8. 常用的辅助类8.1 CountDownLatch12345678910111213141516171819package com.swpu.add;import java.util.concurrent.CountDownLatch;public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;Go Out&quot;); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(&quot;Close Door&quot;); &#125;&#125; 原理： ==countDownLatch.countDown();== //数量-1 ==countDownLatch.await();== //等待计数归零，然后再向下执行 8.2 CyclicBarrier123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功&quot;); &#125;); for (int i = 0; i &lt;= 7; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;收集&quot; + temp + &quot;个龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 8.3 Semaphore123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; // acquire() 得到 try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; // release() 释放 &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理： ==semaphore.acquire();== 获得，假设已经满了。等待，等待被释放为止 ==semaphore.release();== 释放，会将当前的信号量释放+1 9. 读写锁ReadWriteLock 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.rw;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁（写锁） 一次只能被一个线程占有 * 共享锁（读锁） 多个线程可以同时占有 * ReadWriteLock * 读-读 可以共存！ * 读-写 不能共存！ * 写-写 不能共存！ */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); // 写入 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot;,temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; // 读取 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;// 加锁的class MyCacheLock&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 读写锁： 更加细粒度的控制 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private Lock lock = new ReentrantLock(); // 存，写入的时候，只希望同时只有一个线程写 public void put(String key,Object value)&#123; readWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; // 取，读，所有人都可以读！ public void get(String key)&#123; readWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125;/** * 自定义缓存 */class MyCache&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 存，写 public void put(String key,Object value)&#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; // 取，读 public void get(String key)&#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125;&#125; 10. 阻塞队列BlockingQueue 什么情况下我们会使用 阻塞队列：多线程并发处理，线程池 学会使用队列 添加、移除 四组API 方式 抛出异常 有返回值，不抛出异常 阻塞 等待 超时等待 添加 add() offer() put() offer( , , ) 移除 remove() poll() take() poll( , ) 判断队列首 element() peek() - - 抛出异常 不会抛出异常 阻塞 等待 超时等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.bq;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; //test1(); //test2(); //test3(); test4(); &#125; /* 抛出异常 */ public static void test1() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); System.out.println(blockingQueue.add(&quot;a&quot;)); System.out.println(blockingQueue.add(&quot;b&quot;)); System.out.println(blockingQueue.add(&quot;c&quot;)); //IllegalStateException: Queue full //System.out.println(blockingQueue.add(&quot;d&quot;)); System.out.println(blockingQueue.element());//查看队首元素是谁 System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //NoSuchElementException //System.out.println(blockingQueue.remove()); &#125; /* 有返回值，没有异常 */ public static void test2() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;)); //false 不抛出异常 System.out.println(blockingQueue.offer(&quot;c&quot;)); System.out.println(blockingQueue.peek()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); //null System.out.println(blockingQueue.poll()); &#125; /* 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.put(&quot;a&quot;); blockingQueue.put(&quot;b&quot;); blockingQueue.put(&quot;c&quot;); //一直阻塞 //blockingQueue.put(&quot;d&quot;); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //等待 //System.out.println(blockingQueue.take()); &#125; /* 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.offer(&quot;a&quot;); blockingQueue.offer(&quot;b&quot;); blockingQueue.offer(&quot;c&quot;); //等待超过两秒退出 //blockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS)); &#125;&#125; SynchronousQueue 同步队列 12345678910111213141516171819202122232425262728293031323334353637383940package com.swpu.bq;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/*同步队列 */public class SynchronousQueueDemo &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;); blockingQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;); blockingQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;); blockingQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T1&quot;).start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 11. 线程池（重点）线程池：三大方法，七大参数，4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！优化资源的使用！=&gt;池化技术 线程池、连接池、内存池、对象池 创建，销毁，十分浪费资源 池化技术：实现准备好一些资源，有人要用，就来我这里拿，用完之后还给我。 线程池的好处： 降低资源的消耗 提高响应的速度 方便管理 ==线程复用，可以控制最大并发数，管理线程== 线程池：三大方法 1234567891011121314151617181920212223242526package com.swpu.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;// Executors 工具类、三大方法// 使用了线程池之后，使用线程池创建线程public class Demo01 &#123; public static void main(String[] args) &#123; //ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程 //ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小 ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的，遇强则强，遇弱则弱 try &#123; for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; OK&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 七大参数 12. 四大函数式接口lambda表达式，链式编程，函数式接口，Stream流式计算 函数式接口：只有一个方法的接口 Function 函数式接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Function;/** * Function 函数型接口，有一个输入参数，有一个输出 * 只要是 函数型接口 可以用 lambda表达式简化 */public class Demo01 &#123; public static void main(String[] args) &#123;// Function function = new Function&lt;String, String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;; Function function = (str) -&gt; &#123; return str; &#125;; System.out.println(function.apply(&quot;app&quot;)); &#125;&#125; 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Predicate;/** * 断定型接口：有一个输入参数。返回值只能是布尔值 */public class Demo02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// return s.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;&quot;)); &#125;&#125; Consumer 消费性接口 123456789101112131415161718192021package com.swpu.function;import java.util.function.Consumer;/** * Consumer 消费型接口：只有输入，没有返回值 */public class Demo03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;&gt;() &#123;// @Override// public void accept(String s) &#123;// System.out.println(s);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (s) -&gt; &#123; System.out.println(s); &#125;; consumer.accept(&quot;app&quot;); &#125;&#125; Supplier 供给型接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Supplier;/** * Supplier 供给型接口 没有参数，只有返回值 */public class Demo04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;() &#123;// @Override// public Integer get() &#123;// System.out.println(&quot;get()&quot;);// return 1024;// &#125;// &#125;; Supplier supplier = () -&gt; &#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125; 13. Stream流式计算 什么是Stream流式计算 大数据：存储加计算 集合，Mysql 本质就是存储东西的 计算都应该交给流来操作 1234567891011121314151617181920212223242526272829303132333435package com.swpu.stream;import java.util.Arrays;import java.util.List;/** * 题目要求：一分钟内完成此题，只能用一行代码实现！ * 现在有5个用户！筛选： * 1、ID 必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户！ */public class Test &#123; public static void main(String[] args) &#123; User u1 = new User(1,&quot;a&quot;,21); User u2 = new User(2,&quot;b&quot;,22); User u3 = new User(3,&quot;c&quot;,23); User u4 = new User(4,&quot;d&quot;,24); User u5 = new User(6,&quot;e&quot;,25); // 集合就是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-&gt; u.getId()%2==0) .filter(u-&gt; u.getAge()&gt;23) .map(u-&gt; u.getName().toUpperCase()) .sorted((uu1,uu2)-&gt;&#123;return uu2.compareTo(uu1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125; 14. ForkJoin 什么是ForkJoin ForkJoin 在JDK1.7，并执行任务！提高效率，大数据量 大数据：Map Reduce(把大任务拆分为小任务) ForkJoin 特点：工作窃取 这个里面维护的是双端队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.swpu.forkjoin;import java.util.concurrent.RecursiveTask;/** * 求和计算的任务！ * 3000 6000（ForkJoin） 9000（Stream并行流） * // 如何使用 forkjoin * // 1、forkjoinPool 通过它来执行 * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * // 3. 计算类要继承 ForkJoinTask */public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; // 计算方法 @Override protected Long compute() &#123; if ((end - start) &lt; temp) &#123; Long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; else &#123; // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle + 1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.swpu.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;/** * 同一个任务，别人效率高你几十倍！ */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // test1(); // 12224 // test2(); // 10038 // test3(); // 153 &#125; // 普通程序员 public static void test1()&#123; Long sum = 0L; long start = System.currentTimeMillis(); for (Long i = 1L; i &lt;= 10_0000_0000; i++) &#123; sum += i; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; // 会使用ForkJoin public static void test2() throws ExecutionException, InterruptedException &#123; long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, 10_0000_0000L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);// 提交任务 Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; public static void test3()&#123; long start = System.currentTimeMillis(); // Stream并行流 () (] long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+&quot;时间：&quot;+(end-start)); &#125;&#125; 15. 异步回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * 异步调用： CompletableFuture * // 异步执行 * // 成功回调 * // 失败回调 */public class Demo01 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 没有返回值的 runAsync 异步回调// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;// try &#123;// TimeUnit.SECONDS.sleep(2);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);// &#125;);//// System.out.println(&quot;1111&quot;);//// completableFuture.get(); // 获取阻塞执行结果 // 有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;supplyAsync=&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123; System.out.println(&quot;t=&gt;&quot; + t); // 正常的返回结果 System.out.println(&quot;u=&gt;&quot; + u); // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero &#125;).exceptionally((e) -&gt; &#123; System.out.println(e.getMessage()); return 233; // 可以获取到错误的返回结果 &#125;).get()); /** * succee Code 200 * error Code 404 500 */ &#125;&#125; 16. JMM 请你谈谈你对Volatile 的理解 Volatile 是 Java虚拟机提供的轻量级的同步机制， 保证可见性 ==不保证原子性== 禁止指令重排 什么是JMM JMM：java内存模型，不存在的东西。约定，概念 关于JMM的一些同步约定 线程解锁前，必须把共享变量==立刻==刷回主存 线程加锁前，必须读取主存中的最新值到工作内存中 加锁和解锁是同一把锁 17. Volatile 保证可见性 12345678910111213141516171819202122232425262728package com.swpu.tvolatile;import java.util.concurrent.TimeUnit;public class JMMDemo &#123; //不加volatile程序就会死循环！ //加volatile可以保证可见性 private volatile static int num = 0; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (num == 0) &#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 2.不保证原子性 原子性：不可分割 线程A在执行任务的时候，不能被打扰的，也不能被分割，要么同时成功，要么同时失败 1234567891011121314151617181920212223242526package com.swpu.tvolatile;public class VDemo02 &#123; //volatile不保证原子性 private volatile static int num = 0; public static void add() &#123; num++; &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 如果不加lock和synchronized，怎样保证原子性 使用原子类，解决原子性问题 123456789101112131415161718192021222324252627282930package com.swpu.tvolatile;import java.util.concurrent.atomic.AtomicInteger;public class VDemo02 &#123; //volatile不保证原子性 private volatile static AtomicInteger num = new AtomicInteger(); public static void add() &#123; //num++; //不是一个原子性操作 num.getAndIncrement();//AtomInteger + 1 方法 ， CAS &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！ 指令重排 什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行 源代码-&gt;编译器优化的重排-&gt;执行并行也可能会重排-&gt;执行 1234int x = 1;//1int x = 2;//2x = x + 5;//3y = x * x;//4 volatile可以避免指令重排： 内存屏障、CPU指令、作用： 保证制定的操作执行顺序 可以保证某些变量的内存可见性（利用这些特性volatie实现了可见性） Volatile是可以保持可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生 18. 彻底玩转单例模式饿汉式，DCL懒汉式，深究 饿汉式 123456789101112131415161718192021package com.swpu.single;public class Hungry &#123; //可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL懒汉式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.swpu.single;import java.lang.reflect.Constructor;import java.lang.reflect.Field;// 懒汉式单例// 道高一尺，魔高一丈！public class LazyMan &#123; private static boolean qinjiang = false; private LazyMan() &#123; synchronized (LazyMan.class) &#123; if (qinjiang == false) &#123; qinjiang = true; &#125; else &#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; &#125; private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); // 不是一个原子性操作 &#125; &#125; &#125; return lazyMan; &#125; // 反射！ public static void main(String[] args) throws Exception &#123;// LazyMan instance = LazyMan.getInstance(); Field qinjiang = LazyMan.class.getDeclaredField(&quot;qinjiang&quot;); qinjiang.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); qinjiang.set(instance, false); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); &#125;&#125;/* 1. 分配内存空间 2、执行构造方法，初始化对象 3、把这个对象指向这个空间 &lt;p&gt; 123 132 A B // 此时lazyMan还没有完成构造 */ 静态内部类 12345678910111213141516package com.swpu.single;public class Holder &#123; private Holder() &#123; &#125; public static Holder getInstance() &#123; return InnerClass.HOLDER; &#125; public static class InnerClass &#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 19. 深入理解CAS 什么式CAS 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); atomicInteger.getAndIncrement(); System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); &#125;&#125; CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！ 缺点： 1、 循环会耗时 2、一次性只能保证一个共享变量的原子性 3、ABA问题 CAS: ABA问题（狸猫换太子） 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); &#125;&#125; 20. 原子引用 解决ABA问题，引入原子引用！对应的思想：乐观锁！ 带版本号的原子操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.swpu.cas;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicStampedReference;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class CASDemo &#123; //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 // 正常在业务操作，这里面比较的都是一个个对象 static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;a1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Lock lock = new ReentrantLock(true); atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;a&quot;).start(); // 乐观锁的原理相同！ new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;b1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1)); System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;b&quot;).start(); &#125;&#125; 注意： Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实 例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间； 21. 各种锁的理解1. 公平锁，非公平锁公平锁： 非常公平， 不能够插队，必须先来后到！ 非公平锁：非常不公平，可以插队 （默认都是非公平） 2. 可重入锁可重入锁（递归锁） Synchronized 123456789101112131415161718192021222324package com.swpu.lock;public class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;B&quot;).start(); &#125;&#125;class Phone &#123; public synchronized void sms() &#123; System.out.println(Thread.currentThread().getName() + &quot; sms&quot;); call(); &#125; public synchronized void call() &#123; System.out.println(Thread.currentThread().getName() + &quot; call&quot;); &#125;&#125; Lock锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo02 &#123; public static void main(String[] args) &#123; Phone2 phone &#x3D; new Phone2(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; Lock lock &#x3D; new ReentrantLock(); public void sms()&#123; lock.lock(); &#x2F;&#x2F; 细节问题：lock.lock(); lock.unlock(); &#x2F;&#x2F; lock 锁必须配对，否则就会死在里面 lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;sms&quot;); call(); &#x2F;&#x2F; 这里也有锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125; &#125; public void call()&#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 3. 自旋锁 1234567891011121314151617181920212223242526272829303132package com.swpu.lock;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 */public class SpinlockDemo &#123; // int 0 // Thread null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); // 加锁 public void myLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;); // 自旋锁 while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; // 解锁 // 加锁 public void myUnLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnlock&quot;); atomicReference.compareAndSet(thread, null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.swpu.lock;import java.util.concurrent.TimeUnit;public class TestSpinLock &#123; public static void main(String[] args) throws InterruptedException &#123;// ReentrantLock reentrantLock = new ReentrantLock();// reentrantLock.lock();// reentrantLock.unlock(); //底层使用的自旋锁CAS SpinlockDemo lock = new SpinlockDemo(); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T1&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 4. 死锁 死锁是什么 1234567891011121314151617181920212223242526272829303132333435363738394041package com.swpu.lock;import java.util.concurrent.TimeUnit;public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start(); new Thread(new MyThread(lockB, lockA), &quot;T2&quot;).start(); &#125;&#125;class MyThread implements Runnable &#123; private String lockA; private String lockB; public MyThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA); &#125; &#125; &#125;&#125; 解决问题 使用 jps -l 定位进程号 使用 jstack 进程号 找到死锁问题","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"设计模式","slug":"设计模式","date":"2021-02-28T14:20:00.000Z","updated":"2021-04-08T11:52:02.149Z","comments":true,"path":"2021/02/28/设计模式/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式设计模式 创建型模式 ==单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式== 结构型模式 ==适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式== 行为型模式 ==模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式== OOP七大原则 **开闭原则 : **对扩展开放，对修改关闭 **里氏替换原则 : **继承必须确保超类所拥有的性质在子类中仍然成立 **依赖倒置原则 : **要面向接口编程，不要面向实现编程。 **单一职责原则 : **控制类的粒度大小、将对象解耦、提高其内聚性。 **接口隔离原则 : **要为各个类建立它们需要的专用接口 **迪米特法则 : **只与你的直接朋友交谈，不跟“陌生人”说话。 **合成复用原则 : **尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Mysql","slug":"mysql笔记","date":"2021-02-27T07:25:14.000Z","updated":"2021-04-08T11:55:07.042Z","comments":true,"path":"2021/02/27/mysql笔记/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/27/mysql%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MySQL 三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关 规范性和性能的问题 关联查询的表不得超过三张表 考虑商业化的需求和目标，（成本和用户体验）数据库性能 规范性 冗余字段 数据库连接池池化技术：准备一些预先的资源，过来就连接预先准备好的 开源数据源 DBCP C3P0 Druid：阿里 DBCP 需要用到 jar 包 commons-dbcp-x.x ，commons-pool-x.x C3P0 需要用到 jar 包 c3p0-x.x ， mchange-commons-java-x.x Druid url：https://dbaplus.cn/news-155-1531-1.html 客户端/服务端通信协议MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制 当查询语句很长的时候，需要设置max_allowed_packet参数 尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量 查询缓存解析一个语句前，如果缓存是开启的，那么Mysql会检查这个查询语句是否命中查询缓存中的数据。如果恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。查询不会被解析，也不会生成执行计划，更不会执行 如过查询中包括 任何用户自定义函数、存储过程、用户变量、临时表，系统表，不会缓存 设计上优化 多个小表代替一个大表 批量插入代替循环单条插入 合理控制缓存空间大小 SQL_CACHE 和 SQL_NO_CACH 不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会 B+ B- 树 mysql 索引 https://segmentfault.com/a/1190000004690721 B-树有如下特点: 所有键值分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 在关键字全集内做一次查找,性能逼近二分查找； B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于: 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data) 为所有叶子结点增加了一个链指针","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客搭建感想","slug":"Hexo博客搭建感想","date":"2020-04-30T12:50:23.000Z","updated":"2021-03-05T05:27:04.332Z","comments":true,"path":"2020/04/30/Hexo博客搭建感想/","link":"","permalink":"https://lemon-fruit.github.io/2020/04/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%84%9F%E6%83%B3/","excerpt":"Hexo博客搭建感想","text":"Hexo博客搭建感想 一. 搭建过程 因为以前尝试过io的搭建，所以初始绑定ssh的步骤，就跳过了。 hexo的初始化先下载hexo部署插件在进行配置，比如修改根目录下的config.yml 文件的deploy配置 yilia主题的替换将yilia主题clone到本地(文件位置自行决定，建议放在theme主题下) 1git clone http:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 下载完成后进入根目录下的config.yml 文件找到 theme: xxx 修改为 theme: yilia 。 二. 遇到的问题运气较好，没有遇到啥大问题。 搭建博客没有遇到问题是怎么回事呢？搭建博客相信大家都很熟悉，但是搭建博客没有遇到问题是怎么回事呢，下面就让小编带大家一起了解吧。 搭建博客没有遇到问题，其实就是搭建博客没有遇到问题，大家可能会很惊讶搭建博客怎么会没有遇到问题呢？但事实就是这样，小编也感到非常惊讶。 这就是关于搭建博客没有遇到问题的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！ 以上为调侃 在下载live2d时，npm出现过警告，搜索发现是，某个文件定义问题，遂删除根目录下的source文件夹，重新安装解决。 三. 总结 按照视频的方法可以比较简单的完成该任务。 学会了一些hexo的常用命令。 了解了一点点io的部署，分支管理。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Lemon"},{"title":"第一篇博客","slug":"我的第一篇博客","date":"2020-04-30T12:46:25.000Z","updated":"2021-03-05T05:26:49.443Z","comments":true,"path":"2020/04/30/我的第一篇博客/","link":"","permalink":"https://lemon-fruit.github.io/2020/04/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"第一个博客的搭建","text":"第一个博客的搭建 1. git仓库的搭建 1git init 歌曲","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Mysql必知必会 读书笔记","slug":"mysql必知必会","date":"2020-01-31T08:42:25.000Z","updated":"2021-04-08T11:53:21.216Z","comments":true,"path":"2020/01/31/mysql必知必会/","link":"","permalink":"https://lemon-fruit.github.io/2020/01/31/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","excerpt":"MySQL","text":"MySQL 1. 使用MySQL1.1 连接1mysql -u root -p 1.2 选择数据库1USE xxx 1.3 了解数据库和表 返回可用数据库的一个列表 1SHOW DATABASES; 返回当前选择的数据库内可用表的列表 1SHOW TABLES 2. 检索数据2.1 检索单个列 利用SELECT语句从products表中检索一个名为pros_name的列 12SELECT prod_nameFROM products; 2.2 检索多个列 唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须以逗号分隔 2.3 检索所有列 使用通配符 “ * “ 12SELECT *FROM products; 2.4 检索不同的行 使用DISTINCT关键词DISTINCT关键词必须放在列名前 2.5 限制结果 为了返回第一行或前几行，可使用LIMIT子句 123SELECT *FROM productsLIMIT 5; LIMIT 5指示MySQL返回不多于5行 第一行为 0 行 2.6 使用完全限定的表名 类似 12SELECT products.prod_nameFROM crashcourse.products; 3. 排序检索数据3.1 排序检索数据 以prod_name列以字母顺序排序 123SELECT prod_nameFROM productsORDER BY prod_name; 3.2 按多个列排序 为了按多个列排序，只要指定列名，列名之间用逗号分开即可 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 3.3 指定排序方向 降序排序必须指定DESC关键词 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price DESC; DESC关键词只应用到直接位于其前面的列名 使用DESC和LIMIT的组合，可以找出一个列中的最高最低值 4. 过滤数据4.1 使用WHERE子句123SELECT prod_name, prod_prizeFROM productsWHERE prod_price &#x3D; 2.50 4.2 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 4.2.1 检查单个值4.2.2 不匹配检查4.2.3 范围值检查 使用BETWEEM xxx AND xxx 4.2.4 空值检查 WHERE可见见检查空值NULL 123......WHERE xx is NULL; 5. 数据过滤5.1 组合WHERE子句 以AND或OR 5.1.1 AND操作符和OR操作符 优先处理AND 5.2 IN操作符 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name; 5.3 NOT操作符 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name; 6. 用通配符进行过滤6.1 LIKE操作符6.1.1 百分号（%）通配符 __%__表示任何字符出现任何字符任意次数 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &#x27;jet%&#x27; \\\\检索任意以jet开头的词 6.1.2 下划线（_）通配符 下划线的用途和__%__一样，但下划线只匹配单个字符 6.2 使用通配符技巧 不要过度使用通配符 除非必要不要将其放在搜索模式开头 7. 用正则表达式进行搜索7.1 使用MySQL正则表达式7.1.1 基本字符匹配1234SELECT pord_nameFROM productsWHERE prod_name REGEXP &#x27;1000&#x27;ORDER BY prod_name; 7.1.2 进行OR匹配1234SELECT prod_nameFROM productsWHERE prod_name REGEXP &#x27;1000|2000&#x27;ORDER BY prod_name; 未编辑，待更，估计也不会更了8. 创建计算字段8.1 拼接字段 多数DBMS使用 + 或 || 来实现拼接，MySQL则使用Concat()函数来实现 123SELECT Concat(vend_name, &#x27; (&#x27;, vend_country, &#x27;)&#x27;)FROM vendorsORDER BY vend_name; Trim函数 MYSQL支持**RTrim()（去掉串右边的空格），LTrim()（去掉串左边的空格）以及Trim()**（去掉串左右两边的空格） 使用别名123SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;) AS vend_titleFROM vendorsORDER BY vend_name; 输出： 8.3 执行算术计算123SELECT quantity*item_prices AS expanded_priceFROM orderitemsWHERE order_num &#x3D; 20005; 9. 使用数据处理函数9.1 使用函数 大多数SQL实现支持以下类型的函数。 用于处理文本串的文本函数 用于在数据数值上的算术操作 用于处理日期和时间值并从这些值中提取特定成分 返回DBMS正使用的特殊信息 9.1.1 文本处理函数 之前的RTrim() 为文本函数Upper() 函数将文本转换为大写SOUNDEX() 将任何文本串转换为描述其语音表示的字母数字模式的算法 1234SELECT cust_name, cust_contackFROM customersWHERE Soundex(cust_contack) = Soundex(&#x27;Y Lie&#x27;); //可能会匹配到&#x27;Y LEE&#x27; 9.1.2 日期和时间处理函数 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd.//2020-02-01 使用WHERE order_date = 2005-09-01&#39;;不可靠，因为可能存在：2005-09-01 11:30:05,则语句匹配失败 解决方法：WHERE Date(order_date) = &#39;2005-09-01&#39;; 查询某月的内容 123x x xx x xWHERE Year(order_date) = 2005 AND Month(order_date) = 9; 9.1.3 数值处理函数主要用于代数、三角或几何运算| 函 数 | 说 明 || :—– | :—————– || SAbs() | 返回一个数的绝对 || Cos() | 返回一个角度的余弦 || Exp() | 返回一个数的指数值 || Mod() | 返回除操作的余数 || Pi() | 返回圆周率 || Rand() | 返回一个随机数 || Sin() | 返回一个角度的正弦 || Sqrt() | 返回一个数的平方根 || Tan() | 返回一个角度的正切 | 10 汇总数据10.1 聚集函数 聚集函数运行在行组上，计算和返回单个值的函数 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 10.1.1 AVG()函数 只用于单个列&emsp;AVG() 只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出AVG() 函数忽略列值为NULL的行 10.1.2 COUNT()函数 COUNT() 函数有两种使用方式： 使用COUNT(*) 对表中行的数目进行计算，不管列表中包含的是空值（NULL）还是非空值。 使用COUNT(column) 对特定列中的具有值的行进行计算，忽略NULL值。(column为具体的列名) 10.1.3 MAX()函数 MAX() 返回指定列中的最大值（忽略值为NULL的行） 10.1.4 MIN()函数 与MAX() 功能相反 10.1.5 SUM()函数 SUM() 用来返回指定列值的和（同样忽略NULL的行） 10.2 聚集不同值 指定所有的行执行计算，指定ALL参数或不给参数 只包含不同的值，指定DISTINCT参数 10.3 组合聚集函数 SELECT语句可根据需要包含多个聚集函数 11 分组数据11.1 数据分组 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算 11.2 创建分组123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY ven_id; 结果：按vend_id排序并分组数据 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套 如果在使用GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 11.3 过滤分组 HAVING 非常类似于WHERE，目前所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。 1234SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别 WHERE在数据分组前过滤，HAVING在数据分组后过滤。！！！ 11.4 分组和排序 善用ORDER BY 123456SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY ordedr_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 11.5 SELECT子句顺序 子句 SELCET FROM WHERE GROUP BY HAVING ORDER BY LIMIT 12 使用子查询12.1 利用子查询进行过滤p125 即嵌套查询 列必须匹配 12.2 作为计算字段使用子查询 待更新 13 连结表13.1 联结 join 13.1.1 关系表 外键 外键为某一个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系可伸缩性好 13.2 创建联结 规定要联结的所有表及它们如何关联即可 1234SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; 13.2.1 WHERE子句的重要性不要忘了WHERE子句 笛卡尔积 由没有联结条件的表关系返回的结果为笛卡尔积。检索除的行的数目将是一个表中的行数乘以第二个表中的行数。 13.2.2 内部联结 目前所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也成为内部联结。 123SELECT vend_name,pord_name, pord_priceFORM vendors INNER JOIN productsON vendors.vend_id &#x3D; prouducts.vend_id; 13.2.3 联结多个表123456SELECT prod_name, vend_name, prod_price, quantityFROM orderitems, products, vendorsWHERE products.vend_id = vendors.vend_idAND orderitems.prod_id = products.prod_idAND order_num = 20005; 14. 创建高级联结14.1 使用表别名12345SELLECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_id AND oi.order_num = o.oprder_numAND prod_id = &#x27;TNT2&#x27;; 16.2 使用不同类型的联结16.2.1 自联结 第一种子查询 12345SELECT prod_id, prod_nameFROM productsWHERE vend_id &#x3D; (SELECT vend_id FROM products WHERE prod_id &#x3D; &#39;DTNTR&#39;); 第二种联结 1234SELECT p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id &#x3D; p2.vend_id AND p2.prod_id &#x3D; &#39;DTNTR&#39;;","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}