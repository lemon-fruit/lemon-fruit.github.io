{"meta":{"title":"Lemon-Fruit","subtitle":"","description":"","author":"lemon","url":"https://lemon-fruit.github.io"},"pages":[{"title":"","date":"2021-03-03T08:12:39.086Z","updated":"2021-03-03T08:12:39.086Z","comments":true,"path":"404.html","permalink":"https://lemon-fruit.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除","raw":null,"content":null},{"title":"","date":"2021-03-03T08:00:59.874Z","updated":"2021-03-03T08:00:59.874Z","comments":true,"path":"about/index.html","permalink":"https://lemon-fruit.github.io/about/index.html","excerpt":"","text":"这个人很懒，什么都没留下.jpg","raw":null,"content":null},{"title":"所有分类","date":"2021-03-03T08:01:55.133Z","updated":"2021-03-03T08:01:55.133Z","comments":true,"path":"categories/index.html","permalink":"https://lemon-fruit.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2021-03-03T08:04:49.667Z","updated":"2021-03-03T08:04:49.667Z","comments":true,"path":"friends/index.html","permalink":"https://lemon-fruit.github.io/friends/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"所有标签","date":"2021-03-03T08:02:33.808Z","updated":"2021-03-03T08:02:33.808Z","comments":true,"path":"tags/index.html","permalink":"https://lemon-fruit.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2021-03-03T08:03:26.389Z","updated":"2021-03-03T08:03:26.389Z","comments":true,"path":"mylist/index.html","permalink":"https://lemon-fruit.github.io/mylist/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"计算机网络","slug":"计算机网络/计算机网络","date":"2021-04-15T08:05:00.000Z","updated":"2021-05-29T07:46:25.600Z","comments":true,"path":"2021/04/15/计算机网络/计算机网络/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"传输层什么是三次握手？ 第一次握手：建立连接时，客户端发送syn包（syn = x）到服务器，并进入 SYN-SENT（同步已发送） 状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。 第二次握手：服务器收到syn包，必须确认客户的SYN(ack = x + 1)，同时自己也发送一个SYN包 (syn = y)，即SYN + ACK包，此时服务器进入 SYN-RECV（同步收到） 状态 第三次握手：客户端收到服务器的SYN + ACK包，向服务器发送确认包ACK(ack = y + 1)，此包发送完毕，客户端和服务器进入 ESTABLISHED（已建立连接） 状态，完成三次握手。 TCP建立连接可以两次握手吗？为什么?不可以。有两个原因： 可能会出现已失效的连接请求报文段又传到了服务器端。 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。 两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。 可以采用四次握手吗？为什么？可以。但会降低传输效率 四次握手：第二次握手时，Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。四次握手中的二、三可以合并。 第三次握手中，如果客户端的ACK未送达服务器会怎样？服务端：由于Server没有收到ACK确认，因此会重发之前的SYN + ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），客户端收到后会重新传ACK给服务端 客户端： 在服务端进行超时重发的过程中，如果客户端向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取ACK number，进入establish状态 在服务端进入CLOSED状态之后，如果客户端向服务器发送数据，服务器会以RST包应答 如果已经建立连接，但客户端出现了故障怎么办?服务器每收到一次客户端的请求后，都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接 什么是四次挥手 第一次挥手：客户端将FIN置为1，发送一个序列号seq = u （等于前面已经传送过来的数据的最后一个字节的序号加1）给服务端；进入FIN-WAIT-1（终止等待 1）状态； 第二次挥手：服务端收到FIN之后，发送一个ACK=1，acknowledge number= 收到的序列号（u） + 1；进入CLOSE-WAIT（关闭等待）状态。此时TCP连接处于**半关闭(half-close)**状态，客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。 第三次挥手：服务端将FIN置1，发送一个序列号给客户端，1客户端 收到后进入FIN-WAIT-2（终止等待 2），服务端 进入LAST-ACK（最后确认状态）状态； 第四次挥手：Client收到服务器的FIN后，进入TIME-WAIT（时间等待）状态；接着将ACK置1，发送一个acknowledge number = 序列号 + 1 给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2 * MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送 如果第二次挥手时服务器的ACK没有送达服务端会怎样？会重新发送FIN请求 客户端TIME-WAIT状态的意义是什么？第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。 如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 TCP如何实现流量控制？ 使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。 发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://lemon-fruit.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"Spring 5","slug":"Spring/Spring5","date":"2021-04-12T02:46:34.000Z","updated":"2021-05-29T07:50:48.536Z","comments":true,"path":"2021/04/12/Spring/Spring5/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/12/Spring/Spring5/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Spring 5","slug":"Spring-5","permalink":"https://lemon-fruit.github.io/tags/Spring-5/"}]},{"title":"Redis","slug":"Redis/Redis","date":"2021-04-11T08:01:58.000Z","updated":"2021-05-29T07:49:19.464Z","comments":true,"path":"2021/04/11/Redis/Redis/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/11/Redis/Redis/","excerpt":"","text":"缓存穿透问题描述： 客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。 原因可能是：业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数 据。 解决方案： 缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返 回空值。 布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返 回空值。 缓存击穿问题描述： 一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。 解决方案： 永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为 每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问 过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。 缓存雪崩问题描述： 在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中 有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。 解决方案： 避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。 启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/ 错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是 直接返回。 构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以 保持服务的整体可用。","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://lemon-fruit.github.io/tags/Redis/"}]},{"title":"Mysql 45讲 读书笔记","slug":"mysql/Mysql45讲","date":"2021-04-10T01:49:58.000Z","updated":"2021-05-29T07:48:36.689Z","comments":true,"path":"2021/04/10/mysql/Mysql45讲/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/10/mysql/Mysql45%E8%AE%B2/","excerpt":"","text":"一条SQL查询语句是如何执行的 连接器 连接器: 连接器与 客户端建立连接，获取权限，维持和管理连接 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程比较复杂，建议尽量减少建立连接的动作。但如果长连接累积下来，肯导致内存占用过大 解决方案： 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存如果查询命中缓存可以直接返回结果，效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。 适用于静态表 可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。 可以用SQL_CACHE显式指定使用查询缓存： 1mysql&gt; select SQL_CACHE * from T where ID&#x3D;10； 分析器对SQL语句做解析。 如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。 分析器阶段报错 优化器执行器判断有无执行查询的权限 一条SQL更新语句是如何执行的redo logbinlog这两种日志有以下三点不同： redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交 👆图redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。 事务隔离：为什么你改了我还看不见可结合后文：讲事务到底是隔离的还是不隔离的 隔离性和隔离级别ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性） 隔离级别 解决可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。 SQL标准的事务隔离级别包括： 读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。 读提交：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 若隔离级别是“__读未提交__”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。 若是“__读提交__”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 若是“__可重复读__”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若是“__串行化__”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。 可重复读：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 读提交：这个视图是在每个SQL语句开始执行的时候创建的。 读未提交：直接返回记录上的最新值，没有视图概念 串行化：直接用加锁的方式来避免并行访问。 配置的方式是，将启动参数 transaction-isolation 的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。 1234567891011mysql&gt; show variables like &#39;transaction_isolation&#39;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 事务隔离的实现 回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。​ 什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。 为什么尽量不要使用长事务？长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。 事务启动方式MySQL的事务启动方式： 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。 建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。 深入浅出索引（上） 对于数据库的表而言，索引其实就是它的“目录”。 索引的常见模型 哈希表：键 - 值(key - value) 因为不是有序的，所以哈希索引做区间查询的速度是很慢的。哈希表这种结构适用于只有等值查询的场景 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N)) 有序数组在等值查询和范围查询场景中的性能就都非常优秀 更新数据成本高，有序数组索引只适用于静态存储引擎 搜索树 想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。 InnoDB的索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。 建表语句是： 12345mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine&#x3D;InnoDB; 表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。 索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。 基于主键索引和普通索引的查询有什么区别？ 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树； 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为 。 也就是说，基于非主键索引的查询需要多扫描一棵索引树 索引维护从性能和存储空间方面考量，自增主键往往是更合理的选择。 深入浅出索引（下）在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？ 下面是这个表的初始化语句。 12345678mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &#39;&#39;,index k(k))engine&#x3D;InnoDB;insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;); 覆盖索引由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 最左前缀原则B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的 索引下推 无索引下推执行流程 索引下推执行流程 讲全局锁和表锁：给表加个字段怎么有这么多阻碍根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。 全局锁 对整个数据库实例加锁。 MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。 全局锁的典型使用场景是全库逻辑备份。 风险： 如果在主库备份，在备份期间不能更新，业务停摆 如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟。 官方自带的逻辑备份工具mysqldump，当mysqldump使用参数–single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。 一致性读是好，但是前提是引擎要支持这个隔离级别。如果要全库只读，为什么不使用set global readonly = true的方式？ 在有些系统中，readonly的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。 表级锁MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 表锁的语法是：lock tables … read/write可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。MDL：不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用：保证读写的正确性。在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。 讲行锁功过：怎么减少行锁对性能的影响从两阶段锁说起两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。 建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。 死锁和死锁检测死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。 解决方案： 一种策略是：直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。 另一种策略是：发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。 怎么解决由这种热点行更新导致的性能问题呢？ 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用 控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。 将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。 innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 一致性读不会加锁，就不需要做死锁检测； 并不是每次死锁检测都都要扫所有事务。比如某个时刻，事务等待状态是这样的：B在等A，D在等C，现在来了一个E，发现E需要等D，那么E就判断跟D、C是否会形成死锁，这个检测不用管B和A 讲事务到底是隔离的还是不隔离的结合前文：事务隔离：为什么你改了我还看不见 innodb支持RC（读提交）和RR隔离级别实现是用的一致性视图(consistent read view) 事务在启动时会拍一个快照，这个快照是基于整个库的.基于整个库的意思就是说一个事务内，整个库的修改对于该事务都是不可见的(对于快照读的情况)如果在事务内select t表，另外的事务执行了DDL t表，根据发生时间，要么锁住要么报错(参考第六章) 事务是如何实现的MVCC呢? 每个事务都有一个事务ID，叫做transaction id（严格递增） 事务在启动时，找到已提交的最大事务ID记为up_limit_id。 事务在更新一条语句时，比如id=1改为了id=2.会把id=1和该行之前的row trx_id写到undo log里，并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头 再定一个规矩，一个事务要查看一条数据时，必须先用该事务的up_limit_id与该行的transaction id做比对，如果up_limit_id &gt;= transaction id，那么可以看。如果up_limit_id &lt; transaction id，则只能去undo log里去取。去undo log查找数据的时候，也需要做比对，必须up_limit_id&gt;transaction id，才返回数据 什么是当前读由于当前读都是先读后写,只能读当前的值,所以为当前读.会更新事务内的up_limit_id为该事务的transaction id 为什么rr能实现可重复读而rc不能，分两种情况 快照读的情况下，rr不能更新事务内的up_limit_id，而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id，则rc不能可重复读 当前读的情况下，rr是利用record lock+gap lock来实现的，而rc没有gap，所以rc不能可重复读 讲普通索引和唯一索引，应该怎么选择","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://lemon-fruit.github.io/tags/Mysql/"}]},{"title":"CPU上下文切换","slug":"操作系统/CPU上下文切换","date":"2021-04-08T08:50:33.000Z","updated":"2021-05-29T07:45:50.456Z","comments":true,"path":"2021/04/08/操作系统/CPU上下文切换/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","excerpt":"CPU上下文切换\n什么是CPU上下文\n\n CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境.","text":"CPU上下文切换 什么是CPU上下文 CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境. CPU上下文切换的类型： 进程上下文切换 线程上下文切换 中断上下文切换 系统调用 从用户态到内核态转变，需要用到系统调用 一次系统调用的过程，其实发生了两次CPU上下文问切换 系统调用过程中一直是同一个进程在运行 进程上下文切换 进程是由内核来管理和调度的，进程的切换只能发生在内核态 线程上下文切换 线程是调度的基本单位，而进程则是资源拥有的基本单位 线程有自己的私有数据，比如栈和寄存器 中断上下文切换 对同一个CPU，中断处理比进程拥有跟高的优先级 中断上下文切换并不涉及到进程的用户态","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://lemon-fruit.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"深入理解Java虚拟机","slug":"Java/深入理解Java虚拟机","date":"2021-03-31T07:19:13.000Z","updated":"2021-05-29T10:22:06.880Z","comments":true,"path":"2021/03/31/Java/深入理解Java虚拟机/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/31/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"","text":"一、Java代码是怎么运行的？Java虚拟机具体是怎样运行Java字节码的？ 在 HotSpot 里面，上述翻译过程有两种形式： 第一种是解释执行，即逐条将字节码翻译成机器码并执行； 第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。 前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。 Java虚拟机的运行效率究竟是怎样的? C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。 C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。 从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。 总结与实践Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。 二、Java的基本类型Java虚拟机 的boolean类型在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。 Java 的基本类型 char 类型的取值范围则是[0, 65535]，可作为数组索引。 在Java中，正无穷和负无穷是有确切的值，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。 Java基本类型的大小在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。 三、Java虚拟机是如何加载Java类的？ 类加载：从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。 加载加载：查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。 启动类加载器（bootstrap class loader）是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。 双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。 链接链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。 验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。 准备阶段的目的，则是为被加载类的静态字段分配内存。编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。 解析阶段的目的，正是将这些符号引用解析成为实际引用。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。（；链接阶段非必须的） 初始化如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。 如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为&lt; clinit &gt;。 类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行&lt; clinit &gt;方法的过程。Java 虚拟机会通过加锁来确保类的&lt; clinit &gt;方法仅被执行一次。 类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况： 当虚拟机启动时，初始化用户指定的主类； 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类； 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 子类的初始化会触发父类的初始化； 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 使用反射 API 对某个类进行反射调用时，初始化这个类； 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 12345678910111213//单例延迟初始化public class Singleton &#123; private Singleton() &#123; &#125; private static class LazyHolder &#123; static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 四、JVM是如何执行方法调用的？（上）重载和重写重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。 选取的过程共分为三个阶段： 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法； 如果阶段1，没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法； 如果阶段2，没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。 如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。 如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法也构成了重载。 __方法重写__，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。重写调用也是如此：它会根据调用者的动态类型，来选取实际的目标方法。 JVM的静态绑定与动态绑定Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，它是由方法的参数类型以及返回类型所构成。 Java 虚拟机中关于方法重写的判定同样基于方法描述符。 Java 虚拟机中的: 静态绑定：在解析时便能够直接识别目标方法的情况 动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法的情况。 调用指令的符号引用在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。 对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。 在 C 中查找符合名字及描述符的方法。 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。 从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。 对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。 在 I 中查找符合名字及描述符的方法。 如果没有找到，在 Object 类中的公有实例方法中搜索。 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。 经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表^1的索引。 五、JVM是如果执行方法调用的？（下）1. 虚方法调用虚方法调用包括:接口方法调用（invokeinterface）和非私有实例（invokevirtua）的方法调用。 在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。 2. 方法表方法表在类加载阶段构造，他本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法 方法表满足两个特质： 子类方法表中包含父类方法表中的所有方法； 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。 对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。简单来说，实际引用在静态绑定时指向方法的直接地址，动态绑定时指向方法的间接地址。 即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。 3. 内联缓存内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。 对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。为了节省内存空间，Java 虚拟机只采用单态内联缓存。 虽然内联缓存附带内联二字，但是它并没有内联目标方法。任何方法调用除非被内联，否则都会有固定开销。 六、JVM是如何处理异常的？异常的基本概念Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为 RuntimeException 和其他类型。RuntimeException 和 Error 属于非检查异常。其他的 Exception 皆属于检查异常，在触发时需要显式捕获，或者在方法头用 throws 关键字声明。 RuntimeException 和 Error 属于 Java 里的非检查异常（unchecked exception）。其他异常则属于检查异常（checked exception）。程序中自定义的异常应为检查异常，以便最大化利用 Java 编译器的编译时检查。 Java 虚拟机是如何捕获异常的？如果catch 块中触发了新的异常，在 finally 中捕获并且重抛的异常是新的异常，原本的异常会被忽略 Java 7 的Supressed异常以及语法糖","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://lemon-fruit.github.io/tags/JVM/"}]},{"title":"JUC","slug":"Java/JUC","date":"2021-03-01T11:34:49.000Z","updated":"2021-05-29T07:48:24.054Z","comments":true,"path":"2021/03/01/Java/JUC/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/01/Java/JUC/","excerpt":"3.Lock锁（重点）\nSynchronized 和 Lock区别\n","text":"3.Lock锁（重点） Synchronized 和 Lock区别 Synchronized 内置的java关键词，Lock是一个java类 Synchronized 无法 判断获取所得状态，Lock 可以判断是否获取到了锁 Synchronized 会自动释放，Lock必须手动释放锁！如果不是释放锁，死锁 Synchronized 线程1（获得锁），线程2（等待）；Lock锁就不一定等待下去 Synchronized 可重入锁，不可以中断的，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置） Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码 4、生产者和消费者4.1 生产者与消费者问题Synchronized 版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.swpu.pc;/** * 线程之间的通信问题:生产者消费者问题，等待唤醒，通知唤醒 * 线程交替进行 A B 操作同一个变量 num=0 * A num + 1 * B num - 1 */public class A &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data &#123; private int number = 0; public synchronized void increment() throws InterruptedException &#123; if (number != 0) &#123; this.wait(); &#125; number++; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125; public synchronized void decrement() throws InterruptedException &#123; if (number == 0) &#123; this.wait(); &#125; number--; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125;&#125; 问题存在，A B C D 四个线程 （虚假唤醒） if 改为 while 判断 4.2 JUC 版的生产者和消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class B &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data2 &#123; private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void increment() throws InterruptedException &#123; lock.lock(); try &#123; while (number != 0) &#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public synchronized void decrement() throws InterruptedException &#123; lock.lock(); try &#123; while (number == 0) &#123; condition.await(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; Condition 精准的通知和唤醒线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class C &#123; public static void main(String[] args) &#123; Data3 data = new Data3(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printA(); &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printB(); &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printC(); &#125; &#125;, &quot;C&quot;).start(); &#125;&#125;class Data3 &#123; private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; //1 A 2 B 3 C public void printA() &#123; lock.lock(); try &#123; //业务，判断-&gt; 执行 -&gt; 通知 while (number != 1) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;AAAAAAAAA&quot;); number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; lock.lock(); try &#123; while (number != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;BBBBBBBB&quot;); number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; lock.lock(); try &#123; while (number != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;CCCCCCCCCC&quot;); number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 5、八锁现象彻底理解锁 小结 new this 具体的一个手机 static Class 唯一的一个模板 6、集合类不安全6.1 List 不安全1234567891011121314151617181920212223242526272829303132333435package com.swpu.unsafe;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;public class ListTest &#123; public static void main(String[] args) &#123; //并发下ArrayList不安全的 /* 解决方案： 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ //List&lt;String&gt; list = new ArrayList&lt;&gt;(); //List&lt;String&gt; list = new Vector&lt;&gt;(); List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); /* CopyOnWrite 写入时复制 计算机程序设计领域的一种优化策略 多个线程调用的的时候，list，读取的时候，固定的，写入（覆盖） 在写入的时候避免覆盖，造成数据问题 读写分离 */ //List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 6.3 Map 不安全12345678910111213141516171819202122package com.swpu.unsafe;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;public class MapTest &#123; public static void main(String[] args) &#123; //Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 80; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 7. Callable 可以有返回值 可以抛出异常 方法不同，run()/call() 123456789101112131415161718192021222324252627package com.swpu.callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask, &quot;A&quot;).start(); Integer o = (Integer) futureTask.get(); System.out.println(o); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;Call()&quot;); return 1024; &#125;&#125; 细节： 有缓存 结果可能需要等待，会阻塞！ 8. 常用的辅助类8.1 CountDownLatch12345678910111213141516171819package com.swpu.add;import java.util.concurrent.CountDownLatch;public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;Go Out&quot;); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(&quot;Close Door&quot;); &#125;&#125; 原理： ==countDownLatch.countDown();== //数量-1 ==countDownLatch.await();== //等待计数归零，然后再向下执行 8.2 CyclicBarrier123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功&quot;); &#125;); for (int i = 0; i &lt;= 7; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;收集&quot; + temp + &quot;个龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 8.3 Semaphore123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; // acquire() 得到 try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; // release() 释放 &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理： ==semaphore.acquire();== 获得，假设已经满了。等待，等待被释放为止 ==semaphore.release();== 释放，会将当前的信号量释放+1 9. 读写锁ReadWriteLock 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.rw;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁（写锁） 一次只能被一个线程占有 * 共享锁（读锁） 多个线程可以同时占有 * ReadWriteLock * 读-读 可以共存！ * 读-写 不能共存！ * 写-写 不能共存！ */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); // 写入 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot;,temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; // 读取 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;// 加锁的class MyCacheLock&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 读写锁： 更加细粒度的控制 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private Lock lock = new ReentrantLock(); // 存，写入的时候，只希望同时只有一个线程写 public void put(String key,Object value)&#123; readWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; // 取，读，所有人都可以读！ public void get(String key)&#123; readWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125;/** * 自定义缓存 */class MyCache&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 存，写 public void put(String key,Object value)&#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; // 取，读 public void get(String key)&#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125;&#125; 10. 阻塞队列BlockingQueue 什么情况下我们会使用 阻塞队列：多线程并发处理，线程池 学会使用队列 添加、移除 四组API 方式 抛出异常 有返回值，不抛出异常 阻塞 等待 超时等待 添加 add() offer() put() offer( , , ) 移除 remove() poll() take() poll( , ) 判断队列首 element() peek() - - 抛出异常 不会抛出异常 阻塞 等待 超时等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.bq;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; //test1(); //test2(); //test3(); test4(); &#125; /* 抛出异常 */ public static void test1() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); System.out.println(blockingQueue.add(&quot;a&quot;)); System.out.println(blockingQueue.add(&quot;b&quot;)); System.out.println(blockingQueue.add(&quot;c&quot;)); //IllegalStateException: Queue full //System.out.println(blockingQueue.add(&quot;d&quot;)); System.out.println(blockingQueue.element());//查看队首元素是谁 System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //NoSuchElementException //System.out.println(blockingQueue.remove()); &#125; /* 有返回值，没有异常 */ public static void test2() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;)); //false 不抛出异常 System.out.println(blockingQueue.offer(&quot;c&quot;)); System.out.println(blockingQueue.peek()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); //null System.out.println(blockingQueue.poll()); &#125; /* 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.put(&quot;a&quot;); blockingQueue.put(&quot;b&quot;); blockingQueue.put(&quot;c&quot;); //一直阻塞 //blockingQueue.put(&quot;d&quot;); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //等待 //System.out.println(blockingQueue.take()); &#125; /* 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.offer(&quot;a&quot;); blockingQueue.offer(&quot;b&quot;); blockingQueue.offer(&quot;c&quot;); //等待超过两秒退出 //blockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS)); &#125;&#125; SynchronousQueue 同步队列 12345678910111213141516171819202122232425262728293031323334353637383940package com.swpu.bq;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/*同步队列 */public class SynchronousQueueDemo &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;); blockingQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;); blockingQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;); blockingQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T1&quot;).start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 11. 线程池（重点）线程池：三大方法，七大参数，4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！优化资源的使用！=&gt;池化技术 线程池、连接池、内存池、对象池 创建，销毁，十分浪费资源 池化技术：实现准备好一些资源，有人要用，就来我这里拿，用完之后还给我。 线程池的好处： 降低资源的消耗 提高响应的速度 方便管理 ==线程复用，可以控制最大并发数，管理线程== 线程池：三大方法 1234567891011121314151617181920212223242526package com.swpu.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;// Executors 工具类、三大方法// 使用了线程池之后，使用线程池创建线程public class Demo01 &#123; public static void main(String[] args) &#123; //ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程 //ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小 ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的，遇强则强，遇弱则弱 try &#123; for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; OK&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 七大参数 12. 四大函数式接口lambda表达式，链式编程，函数式接口，Stream流式计算 函数式接口：只有一个方法的接口 Function 函数式接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Function;/** * Function 函数型接口，有一个输入参数，有一个输出 * 只要是 函数型接口 可以用 lambda表达式简化 */public class Demo01 &#123; public static void main(String[] args) &#123;// Function function = new Function&lt;String, String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;; Function function = (str) -&gt; &#123; return str; &#125;; System.out.println(function.apply(&quot;app&quot;)); &#125;&#125; 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Predicate;/** * 断定型接口：有一个输入参数。返回值只能是布尔值 */public class Demo02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// return s.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;&quot;)); &#125;&#125; Consumer 消费性接口 123456789101112131415161718192021package com.swpu.function;import java.util.function.Consumer;/** * Consumer 消费型接口：只有输入，没有返回值 */public class Demo03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;&gt;() &#123;// @Override// public void accept(String s) &#123;// System.out.println(s);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (s) -&gt; &#123; System.out.println(s); &#125;; consumer.accept(&quot;app&quot;); &#125;&#125; Supplier 供给型接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Supplier;/** * Supplier 供给型接口 没有参数，只有返回值 */public class Demo04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;() &#123;// @Override// public Integer get() &#123;// System.out.println(&quot;get()&quot;);// return 1024;// &#125;// &#125;; Supplier supplier = () -&gt; &#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125; 13. Stream流式计算 什么是Stream流式计算 大数据：存储加计算 集合，Mysql 本质就是存储东西的 计算都应该交给流来操作 1234567891011121314151617181920212223242526272829303132333435package com.swpu.stream;import java.util.Arrays;import java.util.List;/** * 题目要求：一分钟内完成此题，只能用一行代码实现！ * 现在有5个用户！筛选： * 1、ID 必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户！ */public class Test &#123; public static void main(String[] args) &#123; User u1 = new User(1,&quot;a&quot;,21); User u2 = new User(2,&quot;b&quot;,22); User u3 = new User(3,&quot;c&quot;,23); User u4 = new User(4,&quot;d&quot;,24); User u5 = new User(6,&quot;e&quot;,25); // 集合就是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-&gt; u.getId()%2==0) .filter(u-&gt; u.getAge()&gt;23) .map(u-&gt; u.getName().toUpperCase()) .sorted((uu1,uu2)-&gt;&#123;return uu2.compareTo(uu1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125; 14. ForkJoin 什么是ForkJoin ForkJoin 在JDK1.7，并执行任务！提高效率，大数据量 大数据：Map Reduce(把大任务拆分为小任务) ForkJoin 特点：工作窃取 这个里面维护的是双端队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.swpu.forkjoin;import java.util.concurrent.RecursiveTask;/** * 求和计算的任务！ * 3000 6000（ForkJoin） 9000（Stream并行流） * // 如何使用 forkjoin * // 1、forkjoinPool 通过它来执行 * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * // 3. 计算类要继承 ForkJoinTask */public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; // 计算方法 @Override protected Long compute() &#123; if ((end - start) &lt; temp) &#123; Long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; else &#123; // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle + 1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.swpu.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;/** * 同一个任务，别人效率高你几十倍！ */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // test1(); // 12224 // test2(); // 10038 // test3(); // 153 &#125; // 普通程序员 public static void test1()&#123; Long sum = 0L; long start = System.currentTimeMillis(); for (Long i = 1L; i &lt;= 10_0000_0000; i++) &#123; sum += i; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; // 会使用ForkJoin public static void test2() throws ExecutionException, InterruptedException &#123; long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, 10_0000_0000L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);// 提交任务 Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; public static void test3()&#123; long start = System.currentTimeMillis(); // Stream并行流 () (] long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+&quot;时间：&quot;+(end-start)); &#125;&#125; 15. 异步回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * 异步调用： CompletableFuture * // 异步执行 * // 成功回调 * // 失败回调 */public class Demo01 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 没有返回值的 runAsync 异步回调// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;// try &#123;// TimeUnit.SECONDS.sleep(2);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);// &#125;);//// System.out.println(&quot;1111&quot;);//// completableFuture.get(); // 获取阻塞执行结果 // 有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;supplyAsync=&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123; System.out.println(&quot;t=&gt;&quot; + t); // 正常的返回结果 System.out.println(&quot;u=&gt;&quot; + u); // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero &#125;).exceptionally((e) -&gt; &#123; System.out.println(e.getMessage()); return 233; // 可以获取到错误的返回结果 &#125;).get()); /** * succee Code 200 * error Code 404 500 */ &#125;&#125; 16. JMM 请你谈谈你对Volatile 的理解 Volatile 是 Java虚拟机提供的轻量级的同步机制， 保证可见性 ==不保证原子性== 禁止指令重排 什么是JMM JMM：java内存模型，不存在的东西。约定，概念 关于JMM的一些同步约定 线程解锁前，必须把共享变量==立刻==刷回主存 线程加锁前，必须读取主存中的最新值到工作内存中 加锁和解锁是同一把锁 17. Volatile 保证可见性 12345678910111213141516171819202122232425262728package com.swpu.tvolatile;import java.util.concurrent.TimeUnit;public class JMMDemo &#123; //不加volatile程序就会死循环！ //加volatile可以保证可见性 private volatile static int num = 0; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (num == 0) &#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 2.不保证原子性 原子性：不可分割 线程A在执行任务的时候，不能被打扰的，也不能被分割，要么同时成功，要么同时失败 1234567891011121314151617181920212223242526package com.swpu.tvolatile;public class VDemo02 &#123; //volatile不保证原子性 private volatile static int num = 0; public static void add() &#123; num++; &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 如果不加lock和synchronized，怎样保证原子性 使用原子类，解决原子性问题 123456789101112131415161718192021222324252627282930package com.swpu.tvolatile;import java.util.concurrent.atomic.AtomicInteger;public class VDemo02 &#123; //volatile不保证原子性 private volatile static AtomicInteger num = new AtomicInteger(); public static void add() &#123; //num++; //不是一个原子性操作 num.getAndIncrement();//AtomInteger + 1 方法 ， CAS &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！ 指令重排 什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行 源代码-&gt;编译器优化的重排-&gt;执行并行也可能会重排-&gt;执行 1234int x = 1;//1int x = 2;//2x = x + 5;//3y = x * x;//4 volatile可以避免指令重排： 内存屏障、CPU指令、作用： 保证制定的操作执行顺序 可以保证某些变量的内存可见性（利用这些特性volatie实现了可见性） Volatile是可以保持可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生 18. 彻底玩转单例模式饿汉式，DCL懒汉式，深究 饿汉式 123456789101112131415161718192021package com.swpu.single;public class Hungry &#123; //可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL懒汉式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.swpu.single;import java.lang.reflect.Constructor;import java.lang.reflect.Field;// 懒汉式单例// 道高一尺，魔高一丈！public class LazyMan &#123; private static boolean qinjiang = false; private LazyMan() &#123; synchronized (LazyMan.class) &#123; if (qinjiang == false) &#123; qinjiang = true; &#125; else &#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; &#125; private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); // 不是一个原子性操作 &#125; &#125; &#125; return lazyMan; &#125; // 反射！ public static void main(String[] args) throws Exception &#123;// LazyMan instance = LazyMan.getInstance(); Field qinjiang = LazyMan.class.getDeclaredField(&quot;qinjiang&quot;); qinjiang.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); qinjiang.set(instance, false); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); &#125;&#125;/* 1. 分配内存空间 2、执行构造方法，初始化对象 3、把这个对象指向这个空间 &lt;p&gt; 123 132 A B // 此时lazyMan还没有完成构造 */ 静态内部类 12345678910111213141516package com.swpu.single;public class Holder &#123; private Holder() &#123; &#125; public static Holder getInstance() &#123; return InnerClass.HOLDER; &#125; public static class InnerClass &#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 19. 深入理解CAS 什么式CAS 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); atomicInteger.getAndIncrement(); System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); &#125;&#125; CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！ 缺点： 1、 循环会耗时 2、一次性只能保证一个共享变量的原子性 3、ABA问题 CAS: ABA问题（狸猫换太子） 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); &#125;&#125; 20. 原子引用 解决ABA问题，引入原子引用！对应的思想：乐观锁！ 带版本号的原子操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.swpu.cas;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicStampedReference;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class CASDemo &#123; //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 // 正常在业务操作，这里面比较的都是一个个对象 static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;a1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Lock lock = new ReentrantLock(true); atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;a&quot;).start(); // 乐观锁的原理相同！ new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;b1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1)); System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;b&quot;).start(); &#125;&#125; 注意： Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实 例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间； 21. 各种锁的理解1. 公平锁，非公平锁公平锁： 非常公平， 不能够插队，必须先来后到！ 非公平锁：非常不公平，可以插队 （默认都是非公平） 2. 可重入锁可重入锁（递归锁） Synchronized 123456789101112131415161718192021222324package com.swpu.lock;public class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;B&quot;).start(); &#125;&#125;class Phone &#123; public synchronized void sms() &#123; System.out.println(Thread.currentThread().getName() + &quot; sms&quot;); call(); &#125; public synchronized void call() &#123; System.out.println(Thread.currentThread().getName() + &quot; call&quot;); &#125;&#125; Lock锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo02 &#123; public static void main(String[] args) &#123; Phone2 phone = new Phone2(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; Lock lock = new ReentrantLock(); public void sms()&#123; lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面 lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;sms&quot;); call(); // 这里也有锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125; &#125; public void call()&#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 3. 自旋锁 1234567891011121314151617181920212223242526272829303132package com.swpu.lock;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 */public class SpinlockDemo &#123; // int 0 // Thread null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); // 加锁 public void myLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;); // 自旋锁 while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; // 解锁 // 加锁 public void myUnLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnlock&quot;); atomicReference.compareAndSet(thread, null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.swpu.lock;import java.util.concurrent.TimeUnit;public class TestSpinLock &#123; public static void main(String[] args) throws InterruptedException &#123;// ReentrantLock reentrantLock = new ReentrantLock();// reentrantLock.lock();// reentrantLock.unlock(); //底层使用的自旋锁CAS SpinlockDemo lock = new SpinlockDemo(); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T1&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 4. 死锁 死锁是什么 1234567891011121314151617181920212223242526272829303132333435363738394041package com.swpu.lock;import java.util.concurrent.TimeUnit;public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start(); new Thread(new MyThread(lockB, lockA), &quot;T2&quot;).start(); &#125;&#125;class MyThread implements Runnable &#123; private String lockA; private String lockB; public MyThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA); &#125; &#125; &#125;&#125; 解决问题 使用 jps -l 定位进程号 使用 jstack 进程号 找到死锁问题","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://lemon-fruit.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"设计模式","slug":"设计模式/设计模式","date":"2021-02-28T14:20:00.000Z","updated":"2021-05-29T07:47:56.725Z","comments":true,"path":"2021/02/28/设计模式/设计模式/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式设计模式 创建型模式 单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式 结构型模式 适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式 行为型模式 模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式 OOP七大原则 开闭原则 : 对扩展开放，对修改关闭 里氏替换原则 : 继承必须确保超类所拥有的性质在子类中仍然成立 依赖倒置原则 : 要面向接口编程，不要面向实现编程。 单一职责原则 : 控制类的粒度大小、将对象解耦、提高其内聚性。 接口隔离原则 : 要为各个类建立它们需要的专用接口 迪米特法则 : 只与你的直接朋友交谈，不跟“陌生人”说话。 合成复用原则 : 尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lemon-fruit.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mysql","slug":"mysql/mysql笔记","date":"2021-02-27T07:25:14.000Z","updated":"2021-05-29T07:48:56.993Z","comments":true,"path":"2021/02/27/mysql/mysql笔记/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/27/mysql/mysql%E7%AC%94%E8%AE%B0/","excerpt":"","text":"三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关 规范性和性能的问题 关联查询的表不得超过三张表 考虑商业化的需求和目标，（成本和用户体验）数据库性能 规范性 冗余字段 数据库连接池池化技术：准备一些预先的资源，过来就连接预先准备好的 开源数据源 DBCP C3P0 Druid：阿里 DBCP 需要用到 jar 包 commons-dbcp-x.x ，commons-pool-x.x C3P0 需要用到 jar 包 c3p0-x.x ， mchange-commons-java-x.x Druid url：https://dbaplus.cn/news-155-1531-1.html 客户端/服务端通信协议MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制 当查询语句很长的时候，需要设置max_allowed_packet参数 尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量 查询缓存解析一个语句前，如果缓存是开启的，那么Mysql会检查这个查询语句是否命中查询缓存中的数据。如果恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。查询不会被解析，也不会生成执行计划，更不会执行 如过查询中包括 任何用户自定义函数、存储过程、用户变量、临时表，系统表，不会缓存 设计上优化 多个小表代替一个大表 批量插入代替循环单条插入 合理控制缓存空间大小 SQL_CACHE 和 SQL_NO_CACH 不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会 B+ B- 树 mysql 索引 https://segmentfault.com/a/1190000004690721 B-树有如下特点: 所有键值分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 在关键字全集内做一次查找,性能逼近二分查找； 5. B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于: 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data) 为所有叶子结点增加了一个链指针","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://lemon-fruit.github.io/tags/Mysql/"}]},{"title":"Mysql必知必会 读书笔记","slug":"mysql/mysql必知必会","date":"2020-01-31T08:42:25.000Z","updated":"2021-05-29T07:49:09.883Z","comments":true,"path":"2020/01/31/mysql/mysql必知必会/","link":"","permalink":"https://lemon-fruit.github.io/2020/01/31/mysql/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","excerpt":"","text":"1. 使用MySQL1.1 连接1mysql -u root -p 1.2 选择数据库1USE xxx 1.3 了解数据库和表 返回可用数据库的一个列表 1SHOW DATABASES; 返回当前选择的数据库内可用表的列表 1SHOW TABLES 2. 检索数据2.1 检索单个列 利用SELECT语句从products表中检索一个名为pros_name的列 12SELECT prod_nameFROM products; 2.2 检索多个列 唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须以逗号分隔 2.3 检索所有列 使用通配符 “ * “ 12SELECT *FROM products; 2.4 检索不同的行 使用DISTINCT关键词DISTINCT关键词必须放在列名前 2.5 限制结果 为了返回第一行或前几行，可使用LIMIT子句 123SELECT *FROM productsLIMIT 5; LIMIT 5指示MySQL返回不多于5行 第一行为 0 行 2.6 使用完全限定的表名 类似 12SELECT products.prod_nameFROM crashcourse.products; 3. 排序检索数据3.1 排序检索数据 以prod_name列以字母顺序排序 123SELECT prod_nameFROM productsORDER BY prod_name; 3.2 按多个列排序 为了按多个列排序，只要指定列名，列名之间用逗号分开即可 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 3.3 指定排序方向 降序排序必须指定DESC关键词 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price DESC; DESC关键词只应用到直接位于其前面的列名 使用DESC和LIMIT的组合，可以找出一个列中的最高最低值 4. 过滤数据4.1 使用WHERE子句123SELECT prod_name, prod_prizeFROM productsWHERE prod_price &#x3D; 2.50 4.2 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 4.2.1 检查单个值4.2.2 不匹配检查4.2.3 范围值检查 使用BETWEEN xxx AND xxx 4.2.4 空值检查 WHERE可见见检查空值NULL 123......WHERE xx is NULL; 5. 数据过滤5.1 组合WHERE子句 以AND或OR 5.1.1 AND操作符和OR操作符 优先处理AND 5.2 IN操作符 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name; 5.3 NOT操作符 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name; 6. 用通配符进行过滤6.1 LIKE操作符6.1.1 百分号（%）通配符 __%__表示任何字符出现任何字符任意次数 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &#x27;jet%&#x27; \\\\检索任意以jet开头的词 6.1.2 下划线（_）通配符 下划线的用途和__%__一样，但下划线只匹配单个字符 6.2 使用通配符技巧 不要过度使用通配符 除非必要不要将其放在搜索模式开头 7. 用正则表达式进行搜索7.1 使用MySQL正则表达式7.1.1 基本字符匹配1234SELECT pord_nameFROM productsWHERE prod_name REGEXP &#x27;1000&#x27;ORDER BY prod_name; 7.1.2 进行OR匹配1234SELECT prod_nameFROM productsWHERE prod_name REGEXP &#x27;1000|2000&#x27;ORDER BY prod_name; 未编辑，待更，估计也不会更了8. 创建计算字段8.1 拼接字段 多数DBMS使用 + 或 || 来实现拼接，MySQL则使用Concat()函数来实现 123SELECT Concat(vend_name, &#x27; (&#x27;, vend_country, &#x27;)&#x27;)FROM vendorsORDER BY vend_name; Trim函数 MYSQL支持**RTrim()（去掉串右边的空格），LTrim()（去掉串左边的空格）以及Trim()**（去掉串左右两边的空格） 使用别名123SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;) AS vend_titleFROM vendorsORDER BY vend_name; 输出： 8.3 执行算术计算123SELECT quantity*item_prices AS expanded_priceFROM orderitemsWHERE order_num &#x3D; 20005; 9. 使用数据处理函数9.1 使用函数 大多数SQL实现支持以下类型的函数。 用于处理文本串的文本函数 用于在数据数值上的算术操作 用于处理日期和时间值并从这些值中提取特定成分 返回DBMS正使用的特殊信息 9.1.1 文本处理函数 之前的RTrim() 为文本函数Upper() 函数将文本转换为大写SOUNDEX() 将任何文本串转换为描述其语音表示的字母数字模式的算法 1234SELECT cust_name, cust_contackFROM customersWHERE Soundex(cust_contack) = Soundex(&#x27;Y Lie&#x27;); //可能会匹配到&#x27;Y LEE&#x27; 9.1.2 日期和时间处理函数 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd.//2020-02-01 使用WHERE order_date = 2005-09-01&#39;;不可靠，因为可能存在：2005-09-01 11:30:05,则语句匹配失败 解决方法：WHERE Date(order_date) = &#39;2005-09-01&#39;; 查询某月的内容 123x x xx x xWHERE Year(order_date) = 2005 AND Month(order_date) = 9; 9.1.3 数值处理函数主要用于代数、三角或几何运算| 函 数 | 说 明 || :—– | :—————– || SAbs() | 返回一个数的绝对 || Cos() | 返回一个角度的余弦 || Exp() | 返回一个数的指数值 || Mod() | 返回除操作的余数 || Pi() | 返回圆周率 || Rand() | 返回一个随机数 || Sin() | 返回一个角度的正弦 || Sqrt() | 返回一个数的平方根 || Tan() | 返回一个角度的正切 | 10 汇总数据10.1 聚集函数 聚集函数运行在行组上，计算和返回单个值的函数 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 10.1.1 AVG()函数 只用于单个列&emsp;AVG() 只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出AVG() 函数忽略列值为NULL的行 10.1.2 COUNT()函数 COUNT() 函数有两种使用方式： 使用COUNT(*) 对表中行的数目进行计算，不管列表中包含的是空值（NULL）还是非空值。 使用COUNT(column) 对特定列中的具有值的行进行计算，忽略NULL值。(column为具体的列名) 10.1.3 MAX()函数 MAX() 返回指定列中的最大值（忽略值为NULL的行） 10.1.4 MIN()函数 与MAX() 功能相反 10.1.5 SUM()函数 SUM() 用来返回指定列值的和（同样忽略NULL的行） 10.2 聚集不同值 指定所有的行执行计算，指定ALL参数或不给参数 只包含不同的值，指定DISTINCT参数 10.3 组合聚集函数 SELECT语句可根据需要包含多个聚集函数 11 分组数据11.1 数据分组 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算 11.2 创建分组123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY ven_id; 结果：按vend_id排序并分组数据 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套 如果在使用GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 11.3 过滤分组 HAVING 非常类似于WHERE，目前所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。 1234SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别 WHERE在数据分组前过滤，HAVING在数据分组后过滤。！！！ 11.4 分组和排序 善用ORDER BY 123456SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY ordedr_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 11.5 SELECT子句顺序 子句 SELECT FROM WHERE GROUP BY HAVING ORDER BY LIMIT 12 使用子查询12.1 利用子查询进行过滤p125 即嵌套查询 列必须匹配 12.2 作为计算字段使用子查询 待更新 13 连结表13.1 联结 join 13.1.1 关系表 外键 外键为某一个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系可伸缩性好 13.2 创建联结 规定要联结的所有表及它们如何关联即可 1234SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; 13.2.1 WHERE子句的重要性不要忘了WHERE子句 笛卡尔积 由没有联结条件的表关系返回的结果为笛卡尔积。检索除的行的数目将是一个表中的行数乘以第二个表中的行数。 13.2.2 内部联结 目前所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也成为内部联结。 123SELECT vend_name,pord_name, pord_priceFORM vendors INNER JOIN productsON vendors.vend_id &#x3D; prouducts.vend_id; 13.2.3 联结多个表123456SELECT prod_name, vend_name, prod_price, quantityFROM orderitems, products, vendorsWHERE products.vend_id = vendors.vend_idAND orderitems.prod_id = products.prod_idAND order_num = 20005; 14. 创建高级联结14.1 使用表别名12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_id AND oi.order_num = o.oprder_numAND prod_id = &#x27;TNT2&#x27;; 16.2 使用不同类型的联结16.2.1 自联结 第一种子查询 12345SELECT prod_id, prod_nameFROM productsWHERE vend_id &#x3D; (SELECT vend_id FROM products WHERE prod_id &#x3D; &#39;DTNTR&#39;); 第二种联结 1234SELECT p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id &#x3D; p2.vend_id AND p2.prod_id &#x3D; &#39;DTNTR&#39;;","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://lemon-fruit.github.io/tags/Mysql/"}]}]}