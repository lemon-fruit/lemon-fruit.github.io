{"meta":{"title":"Lemon_Fruit","subtitle":"","description":"","author":"lemon","url":"https://lemon-fruit.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2021-03-03T08:01:55.133Z","updated":"2021-03-03T08:01:55.133Z","comments":true,"path":"categories/index.html","permalink":"https://lemon-fruit.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T08:00:59.874Z","updated":"2021-03-03T08:00:59.874Z","comments":true,"path":"about/index.html","permalink":"https://lemon-fruit.github.io/about/index.html","excerpt":"","text":"这个人很懒，什么都没留下.jpg"},{"title":"","date":"2021-03-03T08:04:49.667Z","updated":"2021-03-03T08:04:49.667Z","comments":true,"path":"friends/index.html","permalink":"https://lemon-fruit.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-03T08:02:33.808Z","updated":"2021-03-03T08:02:33.808Z","comments":true,"path":"tags/index.html","permalink":"https://lemon-fruit.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T08:03:26.389Z","updated":"2021-03-03T08:03:26.389Z","comments":true,"path":"mylist/index.html","permalink":"https://lemon-fruit.github.io/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T08:12:39.086Z","updated":"2021-03-03T08:12:39.086Z","comments":true,"path":"404.html","permalink":"https://lemon-fruit.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"优炫面经","slug":"优炫","date":"2021-04-16T02:18:16.000Z","updated":"2021-04-16T09:49:35.949Z","comments":true,"path":"2021/04/16/优炫/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/16/%E4%BC%98%E7%82%AB/","excerpt":"","text":"自我介绍巴拉巴拉 介绍一下Java学了啥答：主要学了一下 集合 和 线程 介绍一下集合下的类答：Collection下的 List ，Set，Map, Queue 注意：Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。下图👇： List初始化大小，以及怎么扩容答：10，1.5 ArrayList扩容暂存 如何遍历一个List答：使用foreach。 应该还有__Iterator迭代器，将链表变为数组遍历__ 123456789101112131415161718192021222324252627282930import java.util.*; public class Test&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;HAHAHAHA&quot;); //第一种遍历方法使用 For-Each 遍历 List for (String str : list) &#123; //也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式 System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为 for(String str:strArray) 这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 &#123; System.out.println(ite.next()); &#125; &#125;&#125; 扩展：如何遍历Map123456789101112131415161718192021222324252627282930313233343536import java.util.*; public class Test&#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;, &quot;value2&quot;); map.put(&quot;3&quot;, &quot;value3&quot;); //第一种：普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value：&quot;); for (String key : map.keySet()) &#123; System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key)); &#125; //第二种 System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 System.out.println(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); &#125; //第四种 System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) &#123; System.out.println(&quot;value= &quot; + v); &#125; &#125;&#125; static修饰的有什么特点？static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 String可以被继承吗？答：不能，因为String被final修饰，然后答了一部分安全相关问题（SQL注入） 扩展： 在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然 的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访 问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。 字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合 中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性 不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode ，只要使用缓存的 hashcode 即可，这样一来大大提 高了在散列集合中使用 String 对象的性能。 当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字 符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串 常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内 开辟出新的空间，占据更多的内存。 怎么创建线程池以及作用答： 可以使用阿里巴巴的druid（脑子犯抽） 线程池 涉及到的类比如：Executor、Executors、ThreadPoolExector、AbstractExecutorService、 Future、Callable、ScheduledThreadPoolExecutor等等。 系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以 很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或 Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个 Runnable对象的run()或call()方法。从Java 5开始，Java内建支持线程池。新增了一个Executors工厂类来产生线程池，该工厂类包含 如下几个静态工厂方法来创建线程池。创建出来的线程池，都是通过ThreadPoolExecutor类来实现的。 newCachedThreadPool()：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程 将会被缓存在线程池中。 newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。 newSingleThreadExecutor()：创建一个只有单线程的线程池，它相当于调用newFixedThread Pool()方法时传入参数为1。 newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池，它可以在指定延 迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池 内。 newSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行 线程任务。 ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持 给定的并行级别，该方法还会使用多个队列来减少竞争。 ExecutorService newWorkStealingPool()：该方法是前一个方法的简化版本。如果当前机器有4个 CPU，则目标并行级别被设置为4，也就是相当于为前一个方法传入4作为参数。 启动线程时可以直接调用run方法吗？与start方法有何不同？答：不能，忘了 参考链接 run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程。 调用start()方法启动线程时，系统会把该run()方法当成线程执行体来处理。 但如果直接调用线程对象的 run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体 无反问环节，还是自己太菜了总结Java基础知识掌握不牢，线程需要即使好好复习，继续研读《Java并发编程之美》，集合部分需要进行知识补充，开始重新阅读《Java核心技术卷1》。需深入JVM，操作系统，计算机网络。","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://lemon-fruit.github.io/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"Lemon"},{"title":"计算机网络","slug":"计算机网络","date":"2021-04-15T08:05:00.000Z","updated":"2021-04-19T07:30:52.813Z","comments":true,"path":"2021/04/15/计算机网络/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"传输层什么是三次握手？ 第一次握手：建立连接时，客户端发送syn包（syn = x）到服务器，并进入 SYN-SENT（同步已发送） 状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。 第二次握手：服务器收到syn包，必须确认客户的SYN(ack = x + 1)，同时自己也发送一个SYN包 (syn = y)，即SYN + ACK包，此时服务器进入 SYN-RECV（同步收到） 状态 第三次握手：客户端收到服务器的SYN + ACK包，向服务器发送确认包ACK(ack = y + 1)，此包发送完毕，客户端和服务器进入 ESTABLISHED（已建立连接） 状态，完成三次握手。 TCP建立连接可以两次握手吗？为什么?不可以。有两个原因： 可能会出现已失效的连接请求报文段又传到了服务器端。 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。 两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。 可以采用四次握手吗？为什么？可以。但会降低传输效率 四次握手：第二次握手时，Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。四次握手中的二、三可以合并。 第三次握手中，如果客户端的ACK未送达服务器会怎样？服务端：由于Server没有收到ACK确认，因此会重发之前的SYN + ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），客户端收到后会重新传ACK给服务端 客户端： 在服务端进行超时重发的过程中，如果客户端向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取ACK number，进入establish状态 在服务端进入CLOSED状态之后，如果客户端向服务器发送数据，服务器会以RST包应答 如果已经建立连接，但客户端出现了故障怎么办?服务器每收到一次客户端的请求后，都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接 什么是四次挥手 第一次挥手：客户端将FIN置为1，发送一个序列号seq给服务端；进入FIN-WAIT-1（终止等待 1）状态； 第二次挥手：服务端收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE-WAIT（关闭等待）状态。此时TCP连接处于**半关闭(half-close)**状态，客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。 第三次挥手：服务端将FIN置1，发送一个序列号给客户端，1客户端 收到后进入FIN-WAIT-2（终止等待 2），服务端 进入LAST-ACK（最后确认状态）状态； 第四次挥手：Client收到服务器的FIN后，进入TIME-WAIT（时间等待）状态；接着将ACK置1，发送一个acknowledge number = 序列号 + 1 给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2 * MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送 如果第二次挥手时服务器的ACK没有送达服务端会怎样？会重新发送FIN请求 客户端TIME-WAIT状态的意义是什么？第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。 如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 TCP如何实现流量控制？","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Redis","slug":"Redis","date":"2021-04-11T13:25:31.710Z","updated":"2021-04-11T13:24:57.965Z","comments":true,"path":"2021/04/11/Redis/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/11/Redis/","excerpt":"","text":"缓存穿透问题描述： 客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。 原因可能是：业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数 据。 解决方案： 缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返 回空值。 布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返 回空值。 缓存击穿问题描述： 一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。 解决方案： 永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为 每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问 过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。 缓存雪崩问题描述： 在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中 有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。 解决方案： 避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。 启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/ 错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是 直接返回。 构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以 保持服务的整体可用。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Mysql 45讲 读书笔记","slug":"Mysql45讲","date":"2021-04-10T01:49:58.000Z","updated":"2021-04-10T12:46:58.866Z","comments":true,"path":"2021/04/10/Mysql45讲/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/10/Mysql45%E8%AE%B2/","excerpt":"","text":"一条SQL查询语句是如何执行的 连接器 连接器: 连接器与 客户端建立连接，获取权限，维持和管理连接 数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。 短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。 建立连接的过程比较复杂，建议尽量减少建立连接的动作。但如果长连接累积下来，肯导致内存占用过大 解决方案： 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存如果查询命中缓存可以直接返回结果，效率会很高。 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。 适用于静态表 可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。 可以用SQL_CACHE显式指定使用查询缓存： 1mysql&gt; select SQL_CACHE * from T where ID&#x3D;10； 分析器对SQL语句做解析。 如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。 分析器阶段报错 优化器执行器判断有无执行查询的权限 一条SQL更新语句是如何执行的redo logbinlog这两种日志有以下三点不同： redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 两阶段提交 👆图redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。建议设置成1，这样可以保证MySQL异常重启之后数据不丢失。 事务隔离：为什么你改了我还看不见隔离性和隔离级别ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性） 隔离级别 解决可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。 SQL标准的事务隔离级别包括： 读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。 读提交：一个事务提交之后，它做的变更才会被其他事务看到。 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 若隔离级别是“__读未提交__”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。 若是“__读提交__”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 若是“__可重复读__”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若是“__串行化__”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。 可重复读：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 读提交：这个视图是在每个SQL语句开始执行的时候创建的。 读未提交：直接返回记录上的最新值，没有视图概念 串行化：直接用加锁的方式来避免并行访问。 配置的方式是，将启动参数 transaction-isolation 的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。 1234567891011mysql&gt; show variables like &#39;transaction_isolation&#39;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 事务隔离的实现 ​ 回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。​ 什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。 ​ 为什么尽量不要使用长事务？长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。 事务启动方式MySQL的事务启动方式： 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。 建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。 深入浅出索引（上）​ 对于数据库的表而言，索引其实就是它的“目录”。 索引的常见模型 哈希表：键 - 值(key - value) 因为不是有序的，所以哈希索引做区间查询的速度是很慢的。哈希表这种结构适用于只有等值查询的场景 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N)) 有序数组在等值查询和范围查询场景中的性能就都非常优秀 更新数据成本高，有序数组索引只适用于静态存储引擎 搜索树 想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间。 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。 InnoDB的索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。 建表语句是： 12345mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine&#x3D;InnoDB; 表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。 索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。 基于主键索引和普通索引的查询有什么区别？ 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树； 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树 索引维护从性能和存储空间方面考量，自增主键往往是更合理的选择。 深入浅出索引（下）在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？ 下面是这个表的初始化语句。 12345678mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &#39;&#39;,index k(k))engine&#x3D;InnoDB;insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;); 覆盖索引由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 最左前缀原则B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的 索引下推 无索引下推执行流程 索引下推执行流程 讲全局锁和表锁：给表加个字段怎么有这么多阻碍根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。 全局锁全局锁的典型使用场景是全库逻辑备份。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring5","slug":"Spring5","date":"2021-04-08T11:45:18.229Z","updated":"2021-04-08T12:26:15.300Z","comments":true,"path":"2021/04/08/Spring5/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/08/Spring5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CPU上下文切换","slug":"CPU上下文切换","date":"2021-04-08T08:50:33.000Z","updated":"2021-04-08T12:16:03.636Z","comments":true,"path":"2021/04/08/CPU上下文切换/","link":"","permalink":"https://lemon-fruit.github.io/2021/04/08/CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/","excerpt":"CPU上下文切换 什么是CPU上下文 ​ CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境.","text":"CPU上下文切换 什么是CPU上下文 ​ CPU 上下文就是CPU 寄存器和__程序计数器__，它们都是 CPU 在运行任何任务前，必须的依赖环境. CPU上下文切换的类型： 进程上下文切换 线程上下文切换 中断上下文切换 系统调用 从用户态到内核态转变，需要用到系统调用 一次系统调用的过程，其实发生了两次CPU上下文问切换 系统调用过程中一直是同一个进程在运行 进程上下文切换 进程是由内核来管理和调度的，进程的切换只能发生在内核态 线程上下文切换 线程是调度的基本单位，而进程则是资源拥有的基本单位 线程有自己的私有数据，比如栈和寄存器 中断上下文切换 对同一个CPU，中断处理比进程拥有跟高的优先级 中断上下文切换并不涉及到进程的用户态","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Lemon"},{"title":"JVM","slug":"JVM","date":"2021-03-31T07:19:58.000Z","updated":"2021-04-08T12:24:43.748Z","comments":true,"path":"2021/03/31/JVM/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/31/JVM/","excerpt":"","text":"JMM 什么是JMM JMM：java 内存模型 作用：缓存一致性协议，用于定义数据读写的规则","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-03T03:39:33.817Z","updated":"2021-04-08T12:17:00.502Z","comments":true,"path":"2021/03/03/hello-world/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new &quot;My New Post&quot; More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"JUC","slug":"JUC","date":"2021-03-01T11:34:49.000Z","updated":"2021-04-08T12:23:26.631Z","comments":true,"path":"2021/03/01/JUC/","link":"","permalink":"https://lemon-fruit.github.io/2021/03/01/JUC/","excerpt":"3.Lock锁（重点） Synchronized 和 Lock区别","text":"3.Lock锁（重点） Synchronized 和 Lock区别 Synchronized 内置的java关键词，Lock是一个java类 Synchronized 无法 判断获取所得状态，Lock 可以判断是否获取到了锁 Synchronized 会自动释放，Lock必须手动释放锁！如果不是释放锁，死锁 Synchronized 线程1（获得锁），线程2（等待）；Lock锁就不一定等待下去 Synchronized 可重入锁，不可以中断的，非公平；Lock，可重入锁，可以判断锁，非公平（可以自己设置） Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码 4、生产者和消费者4.1 生产者与消费者问题Synchronized 版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.swpu.pc;/** * 线程之间的通信问题:生产者消费者问题，等待唤醒，通知唤醒 * 线程交替进行 A B 操作同一个变量 num=0 * A num + 1 * B num - 1 */public class A &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data &#123; private int number = 0; public synchronized void increment() throws InterruptedException &#123; if (number != 0) &#123; this.wait(); &#125; number++; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125; public synchronized void decrement() throws InterruptedException &#123; if (number == 0) &#123; this.wait(); &#125; number--; this.notifyAll(); System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); &#125;&#125; 问题存在，A B C D 四个线程 （虚假唤醒） if 改为 while 判断 4.2 JUC 版的生产者和消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class B &#123; public static void main(String[] args) &#123; Data data = new Data(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.decrement(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; data.increment(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data2 &#123; private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void increment() throws InterruptedException &#123; lock.lock(); try &#123; while (number != 0) &#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public synchronized void decrement() throws InterruptedException &#123; lock.lock(); try &#123; while (number == 0) &#123; condition.await(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + number); condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; Condition 精准的通知和唤醒线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.swpu.pc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class C &#123; public static void main(String[] args) &#123; Data3 data = new Data3(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printA(); &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printB(); &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; data.printC(); &#125; &#125;, &quot;C&quot;).start(); &#125;&#125;class Data3 &#123; private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; //1 A 2 B 3 C public void printA() &#123; lock.lock(); try &#123; //业务，判断-&gt; 执行 -&gt; 通知 while (number != 1) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;AAAAAAAAA&quot;); number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; lock.lock(); try &#123; while (number != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;BBBBBBBB&quot;); number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; lock.lock(); try &#123; while (number != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;=&gt;CCCCCCCCCC&quot;); number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 5、八锁现象彻底理解锁 小结 new this 具体的一个手机 static Class 唯一的一个模板 6、集合类不安全6.1 List 不安全1234567891011121314151617181920212223242526272829303132333435package com.swpu.unsafe;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;public class ListTest &#123; public static void main(String[] args) &#123; //并发下ArrayList不安全的 /* 解决方案： 1. List&lt;String&gt; list = new Vector&lt;&gt;(); 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ //List&lt;String&gt; list = new ArrayList&lt;&gt;(); //List&lt;String&gt; list = new Vector&lt;&gt;(); List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); /* CopyOnWrite 写入时复制 计算机程序设计领域的一种优化策略 多个线程调用的的时候，list，读取的时候，固定的，写入（覆盖） 在写入的时候避免覆盖，造成数据问题 读写分离 */ //List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 6.3 Map 不安全12345678910111213141516171819202122package com.swpu.unsafe;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;public class MapTest &#123; public static void main(String[] args) &#123; //Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 80; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 7. Callable 可以有返回值 可以抛出异常 方法不同，run()/call() 123456789101112131415161718192021222324252627package com.swpu.callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread);//适配类 new Thread(futureTask, &quot;A&quot;).start(); Integer o = (Integer) futureTask.get(); System.out.println(o); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;Call()&quot;); return 1024; &#125;&#125; 细节： 有缓存 结果可能需要等待，会阻塞！ 8. 常用的辅助类8.1 CountDownLatch12345678910111213141516171819package com.swpu.add;import java.util.concurrent.CountDownLatch;public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;Go Out&quot;); countDownLatch.countDown(); &#125;,String.valueOf(i)).start(); &#125; countDownLatch.await(); System.out.println(&quot;Close Door&quot;); &#125;&#125; 原理： ==countDownLatch.countDown();== //数量-1 ==countDownLatch.await();== //等待计数归零，然后再向下执行 8.2 CyclicBarrier123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功&quot;); &#125;); for (int i = 0; i &lt;= 7; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;收集&quot; + temp + &quot;个龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 8.3 Semaphore123456789101112131415161718192021222324252627package com.swpu.add;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; // acquire() 得到 try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; // release() 释放 &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理： ==semaphore.acquire();== 获得，假设已经满了。等待，等待被释放为止 ==semaphore.release();== 释放，会将当前的信号量释放+1 9. 读写锁ReadWriteLock 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.rw;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 独占锁（写锁） 一次只能被一个线程占有 * 共享锁（读锁） 多个线程可以同时占有 * ReadWriteLock * 读-读 可以共存！ * 读-写 不能共存！ * 写-写 不能共存！ */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); // 写入 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.put(temp+&quot;&quot;,temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; // 读取 for (int i = 1; i &lt;= 5 ; i++) &#123; final int temp = i; new Thread(()-&gt;&#123; myCache.get(temp+&quot;&quot;); &#125;,String.valueOf(i)).start(); &#125; &#125;&#125;// 加锁的class MyCacheLock&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 读写锁： 更加细粒度的控制 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private Lock lock = new ReentrantLock(); // 存，写入的时候，只希望同时只有一个线程写 public void put(String key,Object value)&#123; readWriteLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; // 取，读，所有人都可以读！ public void get(String key)&#123; readWriteLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; readWriteLock.readLock().unlock(); &#125; &#125;&#125;/** * 自定义缓存 */class MyCache&#123; private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 存，写 public void put(String key,Object value)&#123; System.out.println(Thread.currentThread().getName()+&quot;写入&quot;+key); map.put(key,value); System.out.println(Thread.currentThread().getName()+&quot;写入OK&quot;); &#125; // 取，读 public void get(String key)&#123; System.out.println(Thread.currentThread().getName()+&quot;读取&quot;+key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;读取OK&quot;); &#125;&#125; 10. 阻塞队列BlockingQueue 什么情况下我们会使用 阻塞队列：多线程并发处理，线程池 学会使用队列 添加、移除 四组API 方式 抛出异常 有返回值，不抛出异常 阻塞 等待 超时等待 添加 add() offer() put() offer( , , ) 移除 remove() poll() take() poll( , ) 判断队列首 element() peek() - - 抛出异常 不会抛出异常 阻塞 等待 超时等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.swpu.bq;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; //test1(); //test2(); //test3(); test4(); &#125; /* 抛出异常 */ public static void test1() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); System.out.println(blockingQueue.add(&quot;a&quot;)); System.out.println(blockingQueue.add(&quot;b&quot;)); System.out.println(blockingQueue.add(&quot;c&quot;)); //IllegalStateException: Queue full //System.out.println(blockingQueue.add(&quot;d&quot;)); System.out.println(blockingQueue.element());//查看队首元素是谁 System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); System.out.println(blockingQueue.remove()); //NoSuchElementException //System.out.println(blockingQueue.remove()); &#125; /* 有返回值，没有异常 */ public static void test2() &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(blockingQueue.offer(&quot;a&quot;)); System.out.println(blockingQueue.offer(&quot;b&quot;)); System.out.println(blockingQueue.offer(&quot;c&quot;)); //false 不抛出异常 System.out.println(blockingQueue.offer(&quot;c&quot;)); System.out.println(blockingQueue.peek()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); //null System.out.println(blockingQueue.poll()); &#125; /* 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.put(&quot;a&quot;); blockingQueue.put(&quot;b&quot;); blockingQueue.put(&quot;c&quot;); //一直阻塞 //blockingQueue.put(&quot;d&quot;); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); //等待 //System.out.println(blockingQueue.take()); &#125; /* 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException &#123; ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue(3); blockingQueue.offer(&quot;a&quot;); blockingQueue.offer(&quot;b&quot;); blockingQueue.offer(&quot;c&quot;); //等待超过两秒退出 //blockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll()); System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS)); &#125;&#125; SynchronousQueue 同步队列 12345678910111213141516171819202122232425262728293031323334353637383940package com.swpu.bq;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/*同步队列 */public class SynchronousQueueDemo &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;); blockingQueue.put(&quot;1&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;); blockingQueue.put(&quot;2&quot;); System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;); blockingQueue.put(&quot;3&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T1&quot;).start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + &quot; &quot; + blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 11. 线程池（重点）线程池：三大方法，七大参数，4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！优化资源的使用！=&gt;池化技术 线程池、连接池、内存池、对象池 创建，销毁，十分浪费资源 池化技术：实现准备好一些资源，有人要用，就来我这里拿，用完之后还给我。 线程池的好处： 降低资源的消耗 提高响应的速度 方便管理 ==线程复用，可以控制最大并发数，管理线程== 线程池：三大方法 1234567891011121314151617181920212223242526package com.swpu.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;// Executors 工具类、三大方法// 使用了线程池之后，使用线程池创建线程public class Demo01 &#123; public static void main(String[] args) &#123; //ExecutorService threadPool = Executors.newSingleThreadExecutor();// 单个线程 //ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小 ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的，遇强则强，遇弱则弱 try &#123; for (int i = 0; i &lt; 10; i++) &#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; OK&quot;); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 七大参数 12. 四大函数式接口lambda表达式，链式编程，函数式接口，Stream流式计算 函数式接口：只有一个方法的接口 Function 函数式接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Function;/** * Function 函数型接口，有一个输入参数，有一个输出 * 只要是 函数型接口 可以用 lambda表达式简化 */public class Demo01 &#123; public static void main(String[] args) &#123;// Function function = new Function&lt;String, String&gt;() &#123;// @Override// public String apply(String str) &#123;// return str;// &#125;// &#125;; Function function = (str) -&gt; &#123; return str; &#125;; System.out.println(function.apply(&quot;app&quot;)); &#125;&#125; 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Predicate;/** * 断定型接口：有一个输入参数。返回值只能是布尔值 */public class Demo02 &#123; public static void main(String[] args) &#123;// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// return s.isEmpty();// &#125;// &#125;; Predicate&lt;String&gt; predicate = (str)-&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;&quot;)); &#125;&#125; Consumer 消费性接口 123456789101112131415161718192021package com.swpu.function;import java.util.function.Consumer;/** * Consumer 消费型接口：只有输入，没有返回值 */public class Demo03 &#123; public static void main(String[] args) &#123;// Consumer&lt;String&gt; consumer = new Consumer&lt;&gt;() &#123;// @Override// public void accept(String s) &#123;// System.out.println(s);// &#125;// &#125;; Consumer&lt;String&gt; consumer = (s) -&gt; &#123; System.out.println(s); &#125;; consumer.accept(&quot;app&quot;); &#125;&#125; Supplier 供给型接口 12345678910111213141516171819202122package com.swpu.function;import java.util.function.Supplier;/** * Supplier 供给型接口 没有参数，只有返回值 */public class Demo04 &#123; public static void main(String[] args) &#123;// Supplier supplier = new Supplier&lt;Integer&gt;() &#123;// @Override// public Integer get() &#123;// System.out.println(&quot;get()&quot;);// return 1024;// &#125;// &#125;; Supplier supplier = () -&gt; &#123; return 1024; &#125;; System.out.println(supplier.get()); &#125;&#125; 13. Stream流式计算 什么是Stream流式计算 大数据：存储加计算 集合，Mysql 本质就是存储东西的 计算都应该交给流来操作 1234567891011121314151617181920212223242526272829303132333435package com.swpu.stream;import java.util.Arrays;import java.util.List;/** * 题目要求：一分钟内完成此题，只能用一行代码实现！ * 现在有5个用户！筛选： * 1、ID 必须是偶数 * 2、年龄必须大于23岁 * 3、用户名转为大写字母 * 4、用户名字母倒着排序 * 5、只输出一个用户！ */public class Test &#123; public static void main(String[] args) &#123; User u1 = new User(1,&quot;a&quot;,21); User u2 = new User(2,&quot;b&quot;,22); User u3 = new User(3,&quot;c&quot;,23); User u4 = new User(4,&quot;d&quot;,24); User u5 = new User(6,&quot;e&quot;,25); // 集合就是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-&gt; u.getId()%2==0) .filter(u-&gt; u.getAge()&gt;23) .map(u-&gt; u.getName().toUpperCase()) .sorted((uu1,uu2)-&gt;&#123;return uu2.compareTo(uu1);&#125;) .limit(1) .forEach(System.out::println); &#125;&#125; 14. ForkJoin 什么是ForkJoin ForkJoin 在JDK1.7，并执行任务！提高效率，大数据量 大数据：Map Reduce(把大任务拆分为小任务) ForkJoin 特点：工作窃取 这个里面维护的是双端队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.swpu.forkjoin;import java.util.concurrent.RecursiveTask;/** * 求和计算的任务！ * 3000 6000（ForkJoin） 9000（Stream并行流） * // 如何使用 forkjoin * // 1、forkjoinPool 通过它来执行 * // 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * // 3. 计算类要继承 ForkJoinTask */public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; // 计算方法 @Override protected Long compute() &#123; if ((end - start) &lt; temp) &#123; Long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; else &#123; // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle + 1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.swpu.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;/** * 同一个任务，别人效率高你几十倍！ */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // test1(); // 12224 // test2(); // 10038 // test3(); // 153 &#125; // 普通程序员 public static void test1()&#123; Long sum = 0L; long start = System.currentTimeMillis(); for (Long i = 1L; i &lt;= 10_0000_0000; i++) &#123; sum += i; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; // 会使用ForkJoin public static void test2() throws ExecutionException, InterruptedException &#123; long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, 10_0000_0000L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);// 提交任务 Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+sum+&quot; 时间：&quot;+(end-start)); &#125; public static void test3()&#123; long start = System.currentTimeMillis(); // Stream并行流 () (] long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(&quot;sum=&quot;+&quot;时间：&quot;+(end-start)); &#125;&#125; 15. 异步回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * 异步调用： CompletableFuture * // 异步执行 * // 成功回调 * // 失败回调 */public class Demo01 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 没有返回值的 runAsync 异步回调// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(()-&gt;&#123;// try &#123;// TimeUnit.SECONDS.sleep(2);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);// &#125;);//// System.out.println(&quot;1111&quot;);//// completableFuture.get(); // 获取阻塞执行结果 // 有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+&quot;supplyAsync=&gt;Integer&quot;); int i = 10/0; return 1024; &#125;); System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123; System.out.println(&quot;t=&gt;&quot; + t); // 正常的返回结果 System.out.println(&quot;u=&gt;&quot; + u); // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero &#125;).exceptionally((e) -&gt; &#123; System.out.println(e.getMessage()); return 233; // 可以获取到错误的返回结果 &#125;).get()); /** * succee Code 200 * error Code 404 500 */ &#125;&#125; 16. JMM 请你谈谈你对Volatile 的理解 Volatile 是 Java虚拟机提供的轻量级的同步机制， 保证可见性 ==不保证原子性== 禁止指令重排 什么是JMM JMM：java内存模型，不存在的东西。约定，概念 关于JMM的一些同步约定 线程解锁前，必须把共享变量==立刻==刷回主存 线程加锁前，必须读取主存中的最新值到工作内存中 加锁和解锁是同一把锁 17. Volatile 保证可见性 12345678910111213141516171819202122232425262728package com.swpu.tvolatile;import java.util.concurrent.TimeUnit;public class JMMDemo &#123; //不加volatile程序就会死循环！ //加volatile可以保证可见性 private volatile static int num = 0; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (num == 0) &#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 2.不保证原子性 原子性：不可分割 线程A在执行任务的时候，不能被打扰的，也不能被分割，要么同时成功，要么同时失败 1234567891011121314151617181920212223242526package com.swpu.tvolatile;public class VDemo02 &#123; //volatile不保证原子性 private volatile static int num = 0; public static void add() &#123; num++; &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 如果不加lock和synchronized，怎样保证原子性 使用原子类，解决原子性问题 123456789101112131415161718192021222324252627282930package com.swpu.tvolatile;import java.util.concurrent.atomic.AtomicInteger;public class VDemo02 &#123; //volatile不保证原子性 private volatile static AtomicInteger num = new AtomicInteger(); public static void add() &#123; //num++; //不是一个原子性操作 num.getAndIncrement();//AtomInteger + 1 方法 ， CAS &#125; public static void main(String[] args) &#123; //理论上num结果应该为两万 for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！ 指令重排 什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行 源代码-&gt;编译器优化的重排-&gt;执行并行也可能会重排-&gt;执行 1234int x = 1;//1int x = 2;//2x = x + 5;//3y = x * x;//4 volatile可以避免指令重排： 内存屏障、CPU指令、作用： 保证制定的操作执行顺序 可以保证某些变量的内存可见性（利用这些特性volatie实现了可见性） Volatile是可以保持可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生 18. 彻底玩转单例模式饿汉式，DCL懒汉式，深究 饿汉式 123456789101112131415161718192021package com.swpu.single;public class Hungry &#123; //可能会浪费空间 private byte[] data1 = new byte[1024*1024]; private byte[] data2 = new byte[1024*1024]; private byte[] data3 = new byte[1024*1024]; private byte[] data4 = new byte[1024*1024]; private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL懒汉式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.swpu.single;import java.lang.reflect.Constructor;import java.lang.reflect.Field;// 懒汉式单例// 道高一尺，魔高一丈！public class LazyMan &#123; private static boolean qinjiang = false; private LazyMan() &#123; synchronized (LazyMan.class) &#123; if (qinjiang == false) &#123; qinjiang = true; &#125; else &#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; &#125; private volatile static LazyMan lazyMan; // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; lazyMan = new LazyMan(); // 不是一个原子性操作 &#125; &#125; &#125; return lazyMan; &#125; // 反射！ public static void main(String[] args) throws Exception &#123;// LazyMan instance = LazyMan.getInstance(); Field qinjiang = LazyMan.class.getDeclaredField(&quot;qinjiang&quot;); qinjiang.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); qinjiang.set(instance, false); LazyMan instance2 = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(instance2); &#125;&#125;/* 1. 分配内存空间 2、执行构造方法，初始化对象 3、把这个对象指向这个空间 &lt;p&gt; 123 132 A B // 此时lazyMan还没有完成构造 */ 静态内部类 12345678910111213141516package com.swpu.single;public class Holder &#123; private Holder() &#123; &#125; public static Holder getInstance() &#123; return InnerClass.HOLDER; &#125; public static class InnerClass &#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 19. 深入理解CAS 什么式CAS 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); atomicInteger.getAndIncrement(); System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); &#125;&#125; CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就 一直循环！ 缺点： 1、 循环会耗时 2、一次性只能保证一个共享变量的原子性 3、ABA问题 CAS: ABA问题（狸猫换太子） 123456789101112131415161718192021package com.swpu.cas;import java.util.concurrent.atomic.AtomicInteger;public class CASDemo &#123; // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); &#125;&#125; 20. 原子引用 解决ABA问题，引入原子引用！对应的思想：乐观锁！ 带版本号的原子操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.swpu.cas;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicStampedReference;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class CASDemo &#123; //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 // 正常在业务操作，这里面比较的都是一个个对象 static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1); // CAS compareAndSet : 比较并交换！ public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;a1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Lock lock = new ReentrantLock(true); atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(&quot;a2=&gt;&quot; + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(&quot;a3=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;a&quot;).start(); // 乐观锁的原理相同！ new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); // 获得版本号 System.out.println(&quot;b1=&gt;&quot; + stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp, stamp + 1)); System.out.println(&quot;b2=&gt;&quot; + atomicStampedReference.getStamp()); &#125;, &quot;b&quot;).start(); &#125;&#125; 注意： Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实 例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间； 21. 各种锁的理解1. 公平锁，非公平锁公平锁： 非常公平， 不能够插队，必须先来后到！ 非公平锁：非常不公平，可以插队 （默认都是非公平） 2. 可重入锁可重入锁（递归锁） Synchronized 123456789101112131415161718192021222324package com.swpu.lock;public class Demo01 &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; phone.sms(); &#125;, &quot;B&quot;).start(); &#125;&#125;class Phone &#123; public synchronized void sms() &#123; System.out.println(Thread.currentThread().getName() + &quot; sms&quot;); call(); &#125; public synchronized void call() &#123; System.out.println(Thread.currentThread().getName() + &quot; call&quot;); &#125;&#125; Lock锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.swpu.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo02 &#123; public static void main(String[] args) &#123; Phone2 phone = new Phone2(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;A&quot;).start(); new Thread(()-&gt;&#123; phone.sms(); &#125;,&quot;B&quot;).start(); &#125;&#125;class Phone2&#123; Lock lock = new ReentrantLock(); public void sms()&#123; lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面 lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;sms&quot;); call(); // 这里也有锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125; &#125; public void call()&#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + &quot;call&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 3. 自旋锁 1234567891011121314151617181920212223242526272829303132package com.swpu.lock;import java.util.concurrent.atomic.AtomicReference;/** * 自旋锁 */public class SpinlockDemo &#123; // int 0 // Thread null AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); // 加锁 public void myLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;); // 自旋锁 while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; // 解锁 // 加锁 public void myUnLock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnlock&quot;); atomicReference.compareAndSet(thread, null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.swpu.lock;import java.util.concurrent.TimeUnit;public class TestSpinLock &#123; public static void main(String[] args) throws InterruptedException &#123;// ReentrantLock reentrantLock = new ReentrantLock();// reentrantLock.lock();// reentrantLock.unlock(); //底层使用的自旋锁CAS SpinlockDemo lock = new SpinlockDemo(); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T1&quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; &#123; lock.myLock(); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.myUnLock(); &#125; &#125;, &quot;T2&quot;).start(); &#125;&#125; 4. 死锁 死锁是什么 1234567891011121314151617181920212223242526272829303132333435363738394041package com.swpu.lock;import java.util.concurrent.TimeUnit;public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = &quot;lockA&quot;; String lockB = &quot;lockB&quot;; new Thread(new MyThread(lockA, lockB), &quot;T1&quot;).start(); new Thread(new MyThread(lockB, lockA), &quot;T2&quot;).start(); &#125;&#125;class MyThread implements Runnable &#123; private String lockA; private String lockB; public MyThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA); &#125; &#125; &#125;&#125; 解决问题 使用 jps -l 定位进程号 使用 jstack 进程号 找到死锁问题","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"设计模式","slug":"设计模式","date":"2021-02-28T14:20:00.000Z","updated":"2021-04-08T12:13:04.681Z","comments":true,"path":"2021/02/28/设计模式/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式设计模式 创建型模式 单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式 结构型模式 适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式 行为型模式 模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式 OOP七大原则 开闭原则 : 对扩展开放，对修改关闭 里氏替换原则 : 继承必须确保超类所拥有的性质在子类中仍然成立 依赖倒置原则 : 要面向接口编程，不要面向实现编程。 单一职责原则 : 控制类的粒度大小、将对象解耦、提高其内聚性。 接口隔离原则 : 要为各个类建立它们需要的专用接口 迪米特法则 : 只与你的直接朋友交谈，不跟“陌生人”说话。 合成复用原则 : 尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Mysql","slug":"mysql笔记","date":"2021-02-27T07:25:14.000Z","updated":"2021-04-08T12:25:42.034Z","comments":true,"path":"2021/02/27/mysql笔记/","link":"","permalink":"https://lemon-fruit.github.io/2021/02/27/mysql%E7%AC%94%E8%AE%B0/","excerpt":"","text":"三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关 规范性和性能的问题 关联查询的表不得超过三张表 考虑商业化的需求和目标，（成本和用户体验）数据库性能 规范性 冗余字段 数据库连接池池化技术：准备一些预先的资源，过来就连接预先准备好的 开源数据源 DBCP C3P0 Druid：阿里 DBCP 需要用到 jar 包 commons-dbcp-x.x ，commons-pool-x.x C3P0 需要用到 jar 包 c3p0-x.x ， mchange-commons-java-x.x Druid url：https://dbaplus.cn/news-155-1531-1.html 客户端/服务端通信协议MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制 当查询语句很长的时候，需要设置max_allowed_packet参数 尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量 查询缓存解析一个语句前，如果缓存是开启的，那么Mysql会检查这个查询语句是否命中查询缓存中的数据。如果恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。查询不会被解析，也不会生成执行计划，更不会执行 如过查询中包括 任何用户自定义函数、存储过程、用户变量、临时表，系统表，不会缓存 设计上优化 多个小表代替一个大表 批量插入代替循环单条插入 合理控制缓存空间大小 SQL_CACHE 和 SQL_NO_CACH 不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会 B+ B- 树 mysql 索引 https://segmentfault.com/a/1190000004690721 B-树有如下特点: 所有键值分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 在关键字全集内做一次查找,性能逼近二分查找； 5. B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于: 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data) 为所有叶子结点增加了一个链指针","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客搭建感想","slug":"Hexo博客搭建感想","date":"2020-04-30T12:50:23.000Z","updated":"2021-04-08T12:21:09.788Z","comments":true,"path":"2020/04/30/Hexo博客搭建感想/","link":"","permalink":"https://lemon-fruit.github.io/2020/04/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%84%9F%E6%83%B3/","excerpt":"一. 搭建过程","text":"一. 搭建过程 因为以前尝试过io的搭建，所以初始绑定ssh的步骤，就跳过了。 hexo的初始化 先下载hexo部署插件在进行配置，比如修改根目录下的config.yml 文件的deploy配置 yilia主题的替换将yilia主题clone到本地(文件位置自行决定，建议放在theme主题下) 1git clone http:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 下载完成后进入根目录下的config.yml 文件找到 theme: xxx 修改为 theme: yilia 。 二. 遇到的问题运气较好，没有遇到啥大问题。 搭建博客没有遇到问题是怎么回事呢？搭建博客相信大家都很熟悉，但是搭建博客没有遇到问题是怎么回事呢，下面就让小编带大家一起了解吧。 搭建博客没有遇到问题，其实就是搭建博客没有遇到问题，大家可能会很惊讶搭建博客怎么会没有遇到问题呢？但事实就是这样，小编也感到非常惊讶。 这就是关于搭建博客没有遇到问题的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！ 在下载live2d时，npm出现过警告，搜索发现是，某个文件定义问题，遂删除根目录下的source文件夹，重新安装解决。 三. 总结 按照视频的方法可以比较简单的完成该任务。 学会了一些hexo的常用命令。 了解了一点点io的部署，分支管理。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Lemon"},{"title":"第一篇博客","slug":"我的第一篇博客","date":"2020-04-30T12:46:25.000Z","updated":"2021-04-08T12:28:09.250Z","comments":true,"path":"2020/04/30/我的第一篇博客/","link":"","permalink":"https://lemon-fruit.github.io/2020/04/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1. git仓库的搭建 1git init 歌曲","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Mysql必知必会 读书笔记","slug":"mysql必知必会","date":"2020-01-31T08:42:25.000Z","updated":"2021-04-08T12:25:56.941Z","comments":true,"path":"2020/01/31/mysql必知必会/","link":"","permalink":"https://lemon-fruit.github.io/2020/01/31/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","excerpt":"","text":"1. 使用MySQL1.1 连接1mysql -u root -p 1.2 选择数据库1USE xxx 1.3 了解数据库和表 返回可用数据库的一个列表 1SHOW DATABASES; 返回当前选择的数据库内可用表的列表 1SHOW TABLES 2. 检索数据2.1 检索单个列 利用SELECT语句从products表中检索一个名为pros_name的列 12SELECT prod_nameFROM products; 2.2 检索多个列 唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须以逗号分隔 2.3 检索所有列 使用通配符 “ * “ 12SELECT *FROM products; 2.4 检索不同的行 使用DISTINCT关键词DISTINCT关键词必须放在列名前 2.5 限制结果 为了返回第一行或前几行，可使用LIMIT子句 123SELECT *FROM productsLIMIT 5; LIMIT 5指示MySQL返回不多于5行 第一行为 0 行 2.6 使用完全限定的表名 类似 12SELECT products.prod_nameFROM crashcourse.products; 3. 排序检索数据3.1 排序检索数据 以prod_name列以字母顺序排序 123SELECT prod_nameFROM productsORDER BY prod_name; 3.2 按多个列排序 为了按多个列排序，只要指定列名，列名之间用逗号分开即可 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 3.3 指定排序方向 降序排序必须指定DESC关键词 123SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price DESC; DESC关键词只应用到直接位于其前面的列名 使用DESC和LIMIT的组合，可以找出一个列中的最高最低值 4. 过滤数据4.1 使用WHERE子句123SELECT prod_name, prod_prizeFROM productsWHERE prod_price &#x3D; 2.50 4.2 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 4.2.1 检查单个值4.2.2 不匹配检查4.2.3 范围值检查 使用BETWEEN xxx AND xxx 4.2.4 空值检查 WHERE可见见检查空值NULL 123......WHERE xx is NULL; 5. 数据过滤5.1 组合WHERE子句 以AND或OR 5.1.1 AND操作符和OR操作符 优先处理AND 5.2 IN操作符 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id IN (1002,1003)ORDER BY prod_name; 5.3 NOT操作符 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。 1234SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002,1003)ORDER BY prod_name; 6. 用通配符进行过滤6.1 LIKE操作符6.1.1 百分号（%）通配符 __%__表示任何字符出现任何字符任意次数 123SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &#x27;jet%&#x27; \\\\检索任意以jet开头的词 6.1.2 下划线（_）通配符 下划线的用途和__%__一样，但下划线只匹配单个字符 6.2 使用通配符技巧 不要过度使用通配符 除非必要不要将其放在搜索模式开头 7. 用正则表达式进行搜索7.1 使用MySQL正则表达式7.1.1 基本字符匹配1234SELECT pord_nameFROM productsWHERE prod_name REGEXP &#x27;1000&#x27;ORDER BY prod_name; 7.1.2 进行OR匹配1234SELECT prod_nameFROM productsWHERE prod_name REGEXP &#x27;1000|2000&#x27;ORDER BY prod_name; 未编辑，待更，估计也不会更了8. 创建计算字段8.1 拼接字段 多数DBMS使用 + 或 || 来实现拼接，MySQL则使用Concat()函数来实现 123SELECT Concat(vend_name, &#x27; (&#x27;, vend_country, &#x27;)&#x27;)FROM vendorsORDER BY vend_name; Trim函数 MYSQL支持**RTrim()（去掉串右边的空格），LTrim()（去掉串左边的空格）以及Trim()**（去掉串左右两边的空格） 使用别名123SELECT Concat(RTrim(vend_name), &#x27;(&#x27;, RTrim(vend_country),&#x27;)&#x27;) AS vend_titleFROM vendorsORDER BY vend_name; 输出： 8.3 执行算术计算123SELECT quantity*item_prices AS expanded_priceFROM orderitemsWHERE order_num &#x3D; 20005; 9. 使用数据处理函数9.1 使用函数 大多数SQL实现支持以下类型的函数。 用于处理文本串的文本函数 用于在数据数值上的算术操作 用于处理日期和时间值并从这些值中提取特定成分 返回DBMS正使用的特殊信息 9.1.1 文本处理函数 之前的RTrim() 为文本函数Upper() 函数将文本转换为大写SOUNDEX() 将任何文本串转换为描述其语音表示的字母数字模式的算法 1234SELECT cust_name, cust_contackFROM customersWHERE Soundex(cust_contack) = Soundex(&#x27;Y Lie&#x27;); //可能会匹配到&#x27;Y LEE&#x27; 9.1.2 日期和时间处理函数 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd.//2020-02-01 使用WHERE order_date = 2005-09-01&#39;;不可靠，因为可能存在：2005-09-01 11:30:05,则语句匹配失败 解决方法：WHERE Date(order_date) = &#39;2005-09-01&#39;; 查询某月的内容 123x x xx x xWHERE Year(order_date) = 2005 AND Month(order_date) = 9; 9.1.3 数值处理函数主要用于代数、三角或几何运算| 函 数 | 说 明 || :—– | :—————– || SAbs() | 返回一个数的绝对 || Cos() | 返回一个角度的余弦 || Exp() | 返回一个数的指数值 || Mod() | 返回除操作的余数 || Pi() | 返回圆周率 || Rand() | 返回一个随机数 || Sin() | 返回一个角度的正弦 || Sqrt() | 返回一个数的平方根 || Tan() | 返回一个角度的正切 | 10 汇总数据10.1 聚集函数 聚集函数运行在行组上，计算和返回单个值的函数 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 10.1.1 AVG()函数 只用于单个列&emsp;AVG() 只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出AVG() 函数忽略列值为NULL的行 10.1.2 COUNT()函数 COUNT() 函数有两种使用方式： 使用COUNT(*) 对表中行的数目进行计算，不管列表中包含的是空值（NULL）还是非空值。 使用COUNT(column) 对特定列中的具有值的行进行计算，忽略NULL值。(column为具体的列名) 10.1.3 MAX()函数 MAX() 返回指定列中的最大值（忽略值为NULL的行） 10.1.4 MIN()函数 与MAX() 功能相反 10.1.5 SUM()函数 SUM() 用来返回指定列值的和（同样忽略NULL的行） 10.2 聚集不同值 指定所有的行执行计算，指定ALL参数或不给参数 只包含不同的值，指定DISTINCT参数 10.3 组合聚集函数 SELECT语句可根据需要包含多个聚集函数 11 分组数据11.1 数据分组 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算 11.2 创建分组123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY ven_id; 结果：按vend_id排序并分组数据 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套 如果在使用GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 11.3 过滤分组 HAVING 非常类似于WHERE，目前所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。 1234SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别 WHERE在数据分组前过滤，HAVING在数据分组后过滤。！！！ 11.4 分组和排序 善用ORDER BY 123456SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY ordedr_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 11.5 SELECT子句顺序 子句 SELECT FROM WHERE GROUP BY HAVING ORDER BY LIMIT 12 使用子查询12.1 利用子查询进行过滤p125 即嵌套查询 列必须匹配 12.2 作为计算字段使用子查询 待更新 13 连结表13.1 联结 join 13.1.1 关系表 外键 外键为某一个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系可伸缩性好 13.2 创建联结 规定要联结的所有表及它们如何关联即可 1234SELECT vend_name, prod_name, prod_priceFROM vendors, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; 13.2.1 WHERE子句的重要性不要忘了WHERE子句 笛卡尔积 由没有联结条件的表关系返回的结果为笛卡尔积。检索除的行的数目将是一个表中的行数乘以第二个表中的行数。 13.2.2 内部联结 目前所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也成为内部联结。 123SELECT vend_name,pord_name, pord_priceFORM vendors INNER JOIN productsON vendors.vend_id &#x3D; prouducts.vend_id; 13.2.3 联结多个表123456SELECT prod_name, vend_name, prod_price, quantityFROM orderitems, products, vendorsWHERE products.vend_id = vendors.vend_idAND orderitems.prod_id = products.prod_idAND order_num = 20005; 14. 创建高级联结14.1 使用表别名12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_id AND oi.order_num = o.oprder_numAND prod_id = &#x27;TNT2&#x27;; 16.2 使用不同类型的联结16.2.1 自联结 第一种子查询 12345SELECT prod_id, prod_nameFROM productsWHERE vend_id &#x3D; (SELECT vend_id FROM products WHERE prod_id &#x3D; &#39;DTNTR&#39;); 第二种联结 1234SELECT p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id &#x3D; p2.vend_id AND p2.prod_id &#x3D; &#39;DTNTR&#39;;","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://lemon-fruit.github.io/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"笔记","slug":"笔记","permalink":"https://lemon-fruit.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://lemon-fruit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}